# Windowed Objective Function

```{r setup1, include=FALSE, purl=FALSE}
  knitr::opts_chunk$set(eval = FALSE, tidy = FALSE, fig.align = 'center')
```

This chapter defines `of_window` The function computes a defined  
$ofun$ for a given set of windows. It provides an option to summarise the 
findings optained in the interactive functions(`of_explore` and `of_compare`).


```{r, purl=FALSE, eval=TRUE}
  coscos::libraries(coscos,
                    visCOS, 
                    tidyverse)
  # 
  cos_data <- coscos::viscos_example( ) %>% 
    coscos::cook_cosdata()
  window_sizes <- c(168,250,500,1000,2000,4000,6000,8000,10000,15000)
  list_of_windows <- window_of(cos_data,
                              ofun = coscos::of_nse, 
                              lb = -1,
                              window_sizes = window_sizes)
```

Possible plots:
```{r, purl=FALSE, eval=TRUE}
  ggplot(list_of_windows[[1]], aes(x = idx)) + 
    facet_wrap(~le_group, scales = "free_y", ncol = 1) +
    geom_raster(data = subset(list_of_windows[[1]], le_group == "ofun"), aes(x = posixdate, y = key, fill = value)) +
    geom_line(data = subset(list_of_windows[[1]], le_group == "q"), aes(x = posixdate, y = value, color = key))
#
  ggplot(list_of_windows[[2]], aes(x = idx)) + 
    facet_wrap(~le_group, scales = "free_y", ncol = 1) +
    geom_raster(data = subset(list_of_windows[[2]], le_group == "ofun"), aes(x = posixdate, y = key, fill = value)) +
    geom_line(data = subset(list_of_windows[[2]], le_group == "q"), aes(x = posixdate, y = value, color = key))

```

```{r, purl=FALSE, eval=TRUE}
  library(ggridges)
  list_of_windows[[1]] %>% 
    filter(le_group == "ofun") %>% 
    ggplot(., aes(x = value, y = key, fill = key)) + 
      geom_density_ridges(scale = 5, size = 0.1, rel_min_height = 0.01, alpha = 0.5) +
      theme_ridges( ) +
      labs(title = "Densities Basin 1")
  list_of_windows[[2]] %>% 
  filter(le_group == "ofun") %>% 
  ggplot(., aes(x = value, y = key, fill = key)) + 
    geom_density_ridges(scale = 5, size = 0.1, rel_min_height = 0.01, alpha = 0.5) +
    theme_ridges( ) +
    labs(title = "Densities Basin 2")
  list_of_windows %>% 
    bind_rows(.) %>% 
    filter(le_group == "ofun") %>% 
    ggplot(., aes(x = value, y = key, fill = key)) + 
      geom_density_ridges(scale = 5, size = 0.1, rel_min_height = 0.01, alpha = 0.5) +
      theme_ridges( ) +
    labs(legend.title = "time resolution") +
          labs(title = "Densities Basin 1 and 2")
```


## Code 

```{r}
# ---------------------------------------------------------------------------
# Code for cooking data
# authors: Daniel Klotz, Johannes Wesemann, Mathew Herrnegger
# !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

```


```{r}
  # --------------------------------------------------------------------------
#' Objectie Function Rolling Functionallity
#' 
#' Roll an objective fucntion over two sets of data d1 and 2
#' @import dplyr
#' @import purrr 
#' @importFrom magrittr set_names
#'
#' @keywords internal
  roll_roll <- function(d1, 
                        d2 = NULL, 
                        fun,
                        width,
                        ...) {
    # functions: =============================================================
    matrix_to_dataframe <- function(x) {
      if (is.matrix(x)) { x <- as.data.frame(x) }
      return(x)
    }
    funct_bi <- function(which, XX, YY, fun, ...) fun(XX[which], YY[which])
    replace_xvar_entries <- function(le_list,xvar) {
      g <- le_list[names(xvar)]
      le_list[names(xvar)] <- xvar
      return(le_list)
    }
    # calc: ==================================================================
    n <- length(d1)
    from <- pmax((1:n) - width + 1, 1)
    to <- 1:n
    elements <- apply(cbind(from, to), 1, function(x) seq(x[1],x[2])) %>% 
      matrix_to_dataframe(.) %>% 
      set_names(., paste(from, to, sep = ":") )
    skip <- sapply(elements, length) %>% 
      is_less_than(width)
    Xvar <- elements %>% 
      .[!skip] %>% 
      purrr::map_dbl(., function(e_r) funct_bi(e_r,d1,d2,fun))
    Xvar_final <- rep(new(class(Xvar[1]), NA), length(from)) %>% 
      set_names(elements) %>% 
      replace_xvar_entries(.,Xvar)
    return(Xvar_final)
  }

```


```{r}
# --------------------------------------------------------------------------
#' Objectie Function Windowing 
#' 
#' Compute the objective function for a set of windows.
#' @import dplyr
#' @importFrom purrr map2
#' @importFrom tibble as_tibble
#' @importFrom magrittr set_names
#' @importFrom tidyr gather 
#'
#' @export
  window_of <- function(cos_data,
                       ofun,
                       lb = 0.0, 
                       window_sizes = c(20L,500L), 
                       na_filling = FALSE,
                       opts = coscos::viscos_options()) {
    cosdata <- coscos::cook_cosdata(cos_data)
    cosdata_length <- nrow(cosdata)
    o_columns <- cosdata %>%
       select( starts_with(opts[["name_o"]]) )
    s_columns <- cosdata %>%
       select( starts_with(opts[["name_s"]]) )
    data_numbers <- names(o_columns) %>%
      gsub(opts[["name_o"]], "", ., ignore.case = TRUE) %>%
      gsub("\\D", "", ., ignore.case = TRUE)
  # make plotlist: =========================================================
    #ยง care!!  we need to quarantee that step == 0 and window_size == 0 will 
    # $  not make problems!
    if ( min(window_sizes) <= 0 ) {
      stop("minimum window size needs to be zero!")
    } else if( max(window_sizes) >= cosdata_length ) {
      stop("maximum window size needs to be smaller than nrow(cos_data)")
    } 
    all_window_sizes <- window_sizes %>% 
      as.integer(.)
    if (length(all_window_sizes) == 0) {
      stop("`window_size` seems to be ill-defined. Resulting lenght is 0")
    }
  # define functions for roll: =============================================
    na_filler_fun <- function(in_data) {
      if (na_filling) {
        fill_idx <- in_data %>% 
          is.na(.) %>% 
          not(.) %>% 
          which(.) %>% 
          min(.)
        in_data[1:fill_idx] <- in_data[fill_idx]
      }
      return(in_data)
    }
    fill_NAs <- function(in_data) {
      if (na_filling) {
        apply(in_data, 2, na_filler_fun)
      } 
      return(in_data)
    }
    apply_ceilings <- function(in_data) {
      apply(in_data, 2, function(x) pmax(x,lb)) 
    }
    roll_of <- function(o_col, s_col) {
      sapply(all_window_sizes, 
             function(window_size) roll_roll(d1 = o_col,
                                             d2 = s_col,
                                             fun = ofun, 
                                             width = window_size)) %>%
        fill_NAs(.) %>%
        apply_ceilings(.) %>% 
        tibble::as_tibble(.) %>% 
        magrittr::set_names("w" %&% sprintf("%.3i",1:length(all_window_sizes)) %_% "size" %&% all_window_sizes) %>% 
        dplyr::mutate(idx = 1:cosdata_length,
                      posixdate = cos_data[[ opts[["name_COSposix"]] ]],
                      qobs = o_col, 
                      qsim = s_col) %>% 
        tidyr::gather(., key, value, -idx, -posixdate) %>% 
        dplyr::mutate(le_group = ifelse((key == "qobs" | key == "qsim"), "q", "ofun"))
    }
    # apply roll_of 
    window_list <- purrr::map2(o_columns,s_columns, roll_of)
  }

```

