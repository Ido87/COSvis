---
title: "Calculation of Objective Functions"
author: "Daniel Klotz"
date: "12 Juli 2016"
output:
  html_document:
    number_sections: yes
  pdf_document:
    number_sections: yes
---

```{r setup, include=FALSE, purl=FALSE}
  knitr::opts_chunk$set(eval = FALSE, tidy = FALSE)
```

# Introduction
This chapter explains the code to calculate the objective functions $of$ for 
the data and for selected periods. It can be done with the function 
'extract_objective_functions'. **Note** that periods must be marked first to run
the function. This is checked, too.

# Calculate Objective Functions for Subbasins and Periods
In Chapter 3, the objective functions $of$ have been introduced already for the 
interactive analysis of the time series. To get the $of$ values for the periods 
defined with `mark_periods()` and as a summary over the whole timespan, the 
function `extract_objective_functions` can be applied to the prepared data 
series and the results are displayed in the console or can be assigned to a 
variable
```{r, message=3, purl=FALSE, eval=TRUE}
require(visCOS)
require(magrittr)
of_values <- extract_objective_functions(get_runoff_example() %>% mark_periods())
of_values
```

# Code
## `extract_objective_functions`
The purpose of this function is to extract a set of objective functions from
the `runoff_data` data.frame. The objective functions are extracted for each
basin, for the all the periods as a summary and for each period separately.

The head of the functions checks for the required packages, if `runoff_data` is 
a data.frame and if the `viscos_options("name_COSperiod")` exists within
`runoff_data `:
```{r}
#' Get basic objective function for runoff_data
#'
#' Calculate basic objective functions(NSE, KGE, percentage BIAS, Correlation) 
#' for every basin and the chosen periods.
#'
#' @param runoff_data runoff_data data.frame.
#' @return list of basic objective function evaluated for the different
#' hydrological years and over the whole timespan.
#' 
#' @import hydroGOF 
#' @import dplyr
#'
#' @export
extract_objective_functions <- function(runoff_data) {
  assert_dataframe(runoff_data)
  if( !exists(viscos_options("name_COSperiod"), where = runoff_data) ) {
    stop("Error! Period-Column missing in runoff_data; use `mark_periods`")
  }
```

The computational part of the function works as follows. In step (I) the
non-marked periods of `runoff_data` (columns of
`viscos_options("name_COSperiod")` which are smaller then 0) are excluded 
from further calculations. The thereby obtained data.frame is named
`evaluation_data`. 
```{r}
  # (I) reduce necessary computation
  evaluation_data <- 
    runoff_data[ runoff_data[[viscos_options("name_COSperiod")]] > 0, ]
```


Step (II) extracts important information for the
calculations:

- The number of basins (`number_of_basins`) is obtained by getting the names
of the data.frame, applying `tolower` to make them independent of upper and
lower cases and summing up all the name_data1 column,  
- the indices of the marked periods (`periods_in_data`) are obtained by getting
the unique values of the `viscos_options("name_COSperiod")` column, and
- number of periods (`number_of_periods`) are obtained by measuring the length
of `periods_in_data`
```{r}
  # (II) get information
  number_of_basins <- evaluation_data %>%
    names %>%
    unique %>%
    tolower %>%
    grepl(viscos_options("name_data1") , .) %>%
    sum
  periods_in_data <- evaluation_data[[viscos_options("name_COSperiod")]] %>%
    unique
  number_of_periods <- periods_in_data %>% length
```

Step (III) computes the overall objective functions. This is done by copying all
`viscos_options("name_data1")` columns into the `temp_x` variable and all
`viscos_options("name_data2")` into the `temp_y` variable. The former is then
handed as observation and the latter as simulation to the `hydroGOF` functions.
The correlation `obj_fun$CORR` is calculated with 'cor' from base `R`. As `cor` 
returns a whole cross-correlation matrix only the diagonal is extracted with 
`diag`. 
```{r}

  # (III) calculate overall objective functions
  temp_x <- dplyr::select(evaluation_data,starts_with(viscos_options("name_data1"))) %>%
    unname
  temp_y <- dplyr::select(evaluation_data,starts_with(viscos_options("name_data2"))) %>%
    unname
  nse_ <- hydroGOF::NSE(temp_y,temp_x)
  kge_ <- hydroGOF::KGE(temp_y,temp_x)
  pbias_ <- hydroGOF::pbias(temp_y,temp_x)
  corr_ <- cor(temp_y,temp_x) %>% diag(.)

```

Step (IV) is a period-wise a repetition of step (III). Thus, at each 
iteration `k` the given period is filtered from `evaluation_data`
with `dplyr::filtr` before `temp_x` and `temp_y` is calculated.
The so obtained period-wise objective function values are marked by `_period`
```{r}
  # (IV) calulcated period-vise objective functions
    # pre allocation of periodic variables:
    NSE_period <- matrix(nrow = number_of_periods, ncol = as.integer(number_of_basins), data = NA)
    KGE_period <- NSE_period
    pBIAS_period <- NSE_period
    CORR_period <- NSE_period

    # calculation loop # proabbly slow
    for (k in 1:number_of_periods) {
      temp_x <- dplyr::filter(evaluation_data,period == periods_in_data[k]) %>%
        dplyr::select(.,starts_with(viscos_options("name_data1"))) %>%
        unname
      temp_y <- dplyr::filter(evaluation_data,period == periods_in_data[k]) %>%
        dplyr::select(.,starts_with(viscos_options("name_data2"))) %>%
        unname
      NSE_period[k,1:number_of_basins] <- hydroGOF::NSE(temp_y,temp_x)
      KGE_period[k,1:number_of_basins] <- hydroGOF::KGE(temp_y,temp_x)
      pBIAS_period[k,1:number_of_basins] <- hydroGOF::pbias(temp_y,temp_x)
      CORR_period[k,1:number_of_basins] <- cor(temp_y,temp_x) %>% diag(.)
    }
  #
  obj_names <- c("NSE","KGE","pBIAS","CORR", 
                    paste("NSE_period",1:number_of_periods,sep="."), 
                    paste("KGE_period",1:number_of_periods,sep="."),
                    paste("pBIAS_period",1:number_of_periods,sep="."),
                    paste("CORR_period",1:number_of_periods,sep=".")
  )
  obj_fun <- data.frame(of = obj_names, 
                        basin = rbind(nse_,
                                      kge_,
                                      pbias_,
                                      corr_,
                                      NSE_period,
                                      KGE_period,
                                      pBIAS_period,
                                      CORR_period),
                        row.names = NULL)
  return(obj_fun)
}

```



# References
- Gupta, Hoshin V.; Kling, Harald; Yilmaz, Koray K. & Martinez, Guillermo F.
(2009): *Decomposition of the mean squared error and NSE performance criteria:*
*Implications for improving hydrological modelling* (Journal of Hydrology)
