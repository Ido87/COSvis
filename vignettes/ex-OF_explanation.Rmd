---
title: "Explanation of the Objective Functions"
author: 
- "Daniel Klotz, Johannes Wesemann, Mathew Herrnegger"
date: "08 August 2016"
output:
  html_document:
    number_sections: yes
---



```{r setup, include=FALSE, purl=FALSE}
  knitr::opts_chunk$set(eval = FALSE, tidy = FALSE)
```

```{r, eval = TRUE, echo = FALSE, message=FALSE, purl=FALSE}
  require("ggplot2")
  require("hydroGOF")
```

# Introduction
This chapter defines the objective functions $of$ that are used in **visCOS** The 
code for exploring and visualising objective function is defined in
separate sections:

- [Explore Basin-Graphs with objective functions](LP-explore_runoff.html)
- [Explore periodical objective functions](LP-main_of.html)

Currently 4 objective functions are used in **visCOS**. They are calculated from
the data columns of a data.frame defined by `viscos_options("name_o")` and
`viscos_options("name_s")`. Assuming that `name_o` is $x$ and `name_o`
is $y$ they are defined as shown in the following.

```{r, eval = TRUE, echo=FALSE, purl=FALSE}
  # here we define some data for the demonstrational plots
  number_of_data <- 100
  m <- 0
  sd <- 1
  x <- rnorm(number_of_data,m,sd)
  noise <- rnorm(number_of_data,m,0.5*sd)
  demo_data <- data.frame(
    x = x,
    t = 1:length(x),
    # y:
    y_0 = noise,
    y_m1 = -x,
    y_1 = x,
    y_2 = x^2,
    y_mh = -x + 2*noise,
    y_h = x + 2*noise
  )  
  demo_names <- names(demo_data)
  demo_length <- length(demo_names)

  # since I do not want to many dependencies and need to plot more functions into
  # one plot I am gonna use the `multiplot` function by Winson Chang
# see: http://www.cookbook-r.com/Graphs/Multiple_graphs_on_one_page_(ggplot2)/
multiplot <- function(..., plotlist=NULL, cols) {
    require(grid, quietly = TRUE)
    # Make a list from the ... arguments and plotlist
    plots <- c(list(...), plotlist)
    numPlots = length(plots)
    # Make the panel
    plotCols = cols                          # Number of columns of plots
    plotRows = ceiling(numPlots/plotCols) # Number of rows needed, calculated from # of cols
    # Set up the page
    grid.newpage()
    pushViewport(viewport(layout = grid.layout(plotRows, plotCols)))
    vplayout <- function(x, y)
        viewport(layout.pos.row = x, layout.pos.col = y)
    # Make each plot, in the correct location
    for (i in 1:numPlots) {
        curRow = ceiling(i/plotCols)
        curCol = (i-1) %% plotCols + 1
        print(plots[[i]], vp = vplayout(curRow, curCol ))
    }
}
## make_plotlist function for multiplot: 
make_plotlist <- function(plot_data, of = mse, of_designation = "MSE(z)") {
  plot_list <- list()
  data_length <- dim(plot_data)[2]
  data_names <- names(plot_data)
  # 
  for (i in 3:data_length) {
    name_i <- data_names[i]
    obj_i <- of( obs = plot_data["x"] , sim = plot_data[name_i])
    title_i <- paste(of_designation,"=", round(obj_i,2), sep = " ")
    plot_list[[i-2]] <- ggplot(plot_data) +
      geom_line(aes_string(x = "t", y = x, color = '"x"')) +
      geom_line(aes_string(x = "t", y = name_i, color = '"y"'),linetype = 5) +
      scale_colour_manual("", 
                        breaks = c("x", "y"),
                        values = c("steelblue", "palevioletred")) +
      ggtitle( title_i ) + 
      xlab( "" ) +
      ylab( "" ) + 
      theme_minimal() +
      theme(axis.text.x = element_blank(),
            axis.text.y = element_blank())
  }
  return(plot_list)
}
```

## Nash-Sutcliffe Efficiency
The Nash-Sutcliffe Criterion $NSE$ is by far the most used efficiency criterion
in hydrology. In the hydrological context $x$ usually represents a set of
runoff-observation and $y$ a set of simulations. The $NSE$ is defined in the
same way as the general definition of the coefficient of determination $R^2$:

$$NSE = \sum_{t=1}^T \frac{x(t)-y(t)}{x(t)-\bar{x}}.$$

The variable $\bar{x}$ represents the average of $x$. The $NSE$
can therefore be seen as the relational the estimator $y$ and the estimator
resulting form the average of the data. It can can have values between minus 
infinity and 1 with 1 being the perfect fit, 0 when the mean of $y$ is as 
good as the mean of $x$ and negative values are even worse.
The following figures illustrate
different $NSE$ values for naive examples.
```{r, eval = TRUE, echo=FALSE, purl=FALSE}
  # examples:
  plot_list <- make_plotlist(demo_data, of = NSE, of_designation = "NSE")
```
```{r, fig.align = "center", eval = TRUE, echo=FALSE, purl=FALSE}
  multiplot(plotlist = plot_list[1:3], cols = 1 )
```
```{r, fig.align = "center", eval = TRUE, echo=FALSE, purl=FALSE}
  multiplot(plotlist = plot_list[4:6], cols = 1 )
```


## Kling-Gupta Efficiency
The Kling-Gupta Efficiency $KGE$ was introduced by Gupta et al. (2009) to
alleviate some of the shortcomings of the $NSE$. In their paper they argue
why the $NSE$ tends to overate simulations with small variance
(note: in the context of the paper $\textrm{simulations} = y$) and
propose their efficiency criterion instead.

The $KGE$ is defined as:

$$ KGE = 1 - ED, $$

with

$$ ED = \sqrt{ (corr-1)^2 + (\alpha-1)^2 + (\beta-1)^2) }; $$

Where $\alpha = \frac{\sigma_y}{ \sigma_x }$ is the standard deviation
$\sigma$ of $y$ divided by the $\sigma$  of $x$, $\beta = \mu_y / \mu_x$ with 
$\mu$ being the arithmetic mean and $corr$ as the 
Pearson's correlation coefficient (see chapter 1.4).

The value range and the quality is similar to the $NSE$. The following figures 
exemplify its usage for the same data as above.

```{r, eval = TRUE, echo=FALSE, purl=FALSE}
  # examples:
  plot_list <- make_plotlist(demo_data, of = KGE, of_designation = "KGE")
```
```{r, fig.align = "center", eval = TRUE, echo=FALSE, purl=FALSE}
  multiplot(plotlist = plot_list[1:3], cols = 1 )
```
```{r, fig.align = "center", eval = TRUE, echo=FALSE, purl=FALSE}
  multiplot(plotlist = plot_list[4:6], cols = 1 )
```

## Percentage Bias
The percentage of bias $p_{bias}$ is defined as the sum of the differences
between $x$ and $y$ divided by the sum of $x$:

$$p_{bias} = 100*\frac{\sum_{} [ x(t)-y(t) ] }{\sum_{} x(t)}.$$

The $100*$ is just a scaling factor applied to express $p_{bias}$ as a percentage.
The following figure illustrates different $p_{bias}$ values for the same data
as above.

```{r, eval = TRUE, echo=FALSE, purl=FALSE}
  # examples:
  plot_list <- make_plotlist(demo_data, of = pbias, of_designation = "p_bias")
```
```{r, fig.align = "center", eval = TRUE, echo=FALSE, purl=FALSE}
  multiplot(plotlist = plot_list[1:3], cols = 1 )
```
```{r, fig.align = "center", eval = TRUE, echo=FALSE, purl=FALSE}
  multiplot(plotlist = plot_list[4:6], cols = 1 )
```

## Pearson's correlation coefficient
The correlation coefficient $corr$ is a measure of the linear relationship
between $x$ and $y$. It is defined as:

$$r \equiv corr = \frac{cov(x,y)}{\sigma_y*\sigma_x},$$

where $cov(...)$ denotes the covariance and $\sigma^2$ the variance. The correlation
coefficient can take on values between -1 and 1. The former corresponds to an
inverse and the latter to a direct relationship and the closer the values
is to zero the weaker is the implied correlation. The following figures display
the $corr$ for the previously used data:

```{r, eval = TRUE, echo=FALSE, purl=FALSE}
  # examples:
  of_corr <- function(obs,sim) {diag(cor(obs,sim))}
  plot_list <- make_plotlist(demo_data, of = of_corr, of_designation = "corr")
```
```{r, fig.align = "center", eval = TRUE, echo=FALSE, purl=FALSE}
  multiplot(plotlist = plot_list[1:3], cols = 1 )
```
```{r, fig.align = "center", eval = TRUE, echo=FALSE, purl=FALSE}
  multiplot(plotlist = plot_list[4:6], cols = 1 )
```

To get a better understanding of the data and the correlation in special it can 
be usefull to plot the data in a scatter plot with $x$ as the abscissa and $y$ 
as the ordinate: 
```{r, fig.align = "center", eval = TRUE, echo=FALSE, purl=FALSE}
# examples:
plot_list <- list()
for (i in 3:demo_length) {
  name_i <- demo_names[i]
  obj_i <- cor( x = demo_data["x"] , y = demo_data[name_i])
  title_i <- paste("corr = ", round(obj_i,2), sep = "")
  plot_list[[i-2]] <- ggplot(demo_data) +
    geom_point(aes_string(x = "x", y = name_i)) +
    xlab( title_i ) +
    ylab("") +
    theme_minimal() +
    theme(axis.text.x = element_blank(),
          axis.text.y = element_blank())
}
multiplot(plotlist = plot_list, cols = 3 )
```

