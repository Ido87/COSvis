# Cooking Data

```{r setup1, include=FALSE, purl=FALSE}
  knitr::opts_chunk$set(eval = FALSE, tidy = FALSE, fig.align = 'center')
```

Within **visCOS** "cooking data" is is used as a synonym for the process of
transforming *raw data* into *cooked data*. Here, *cooked data* is data in the
[COSERO data.frame](Introduction.html) format. *Cooked data* can be eaten or 
served. That is, is can be used for the furhter analysis and to generate figures. 
The package provides a set of basic functions cooking data. 

## Raw Data
Raw-data are time-series of observations $o$ and model simulations $s$.
Usually raw data is saved in some simple file format, e.g. *.txt* or *.csv*.
`R` natively includes many options to read those files, e.g. with the 
`read.table` functions (simply enter `?read.table` in your `R` terminalto 
get an overview). For larger (unstructured) files we recommend the read options 
of the `data.table` package. In our tests it was fastest and most flexible 
alternative. If the data is better structured (and large) you might also want 
to try the `readr` package.

## Cooked Data
In order to learn how to cook data it is usefull to know what cooked data is. 
This section will describe the basic data structure used to enable 
visualizations in **visCOS** 

Currently **visCOS** only allows to compare between *numbered catchments*! The
data **must** include an integer number at the end of its name, e.g.
`QObs_001` and `QSim_001`).

## Examples 
The function `get_viscos_example` can be used to get some exemplary data
from within **visCOS**:
```{r, purl=FALSE, eval=TRUE, message=3:5}
  library(visCOS)
  require(magrittr)
  options(width=80)
  runoff_example_raw <- get_viscos_example()
  head(runoff_example_raw)
```

The next step would be to adapt the options
([`viscos_options`](LP-viscos_options.html), but in this case the options
are already set as in the data:
```{r, purl=FALSE, eval=TRUE}
   viscos_options() %>% unlist()
```

However, a glimpse of the data above shows that some of the columns
(`QOSI_0001` and `QOSI_0002`) are not needed for the analysis.
All the junk data, i.e. data columns that are not defined within the options and
unobserved columns can be removed using the `remove_junk` function.
Additionally **visCOS** needs to have two different ways to define the date
of a given row (see: [Introduction](Introduction.html)). In the runoff_example
each part of the date definition is defined with a column: "yyyy" - year,
"mm" - month, "hh" - hour, "min" - minute.
The other needed format is the POSIXct` format (see: [link](https://stat.ethz.ch/R-manual/R-devel/library/base/html/as.POSIXlt.html))
format often used within R. Here all the information is saved within one column
Given one date format is available in the data.frame the other can be
generated by using `complete_dates`.
```{r, purl=FALSE, eval=TRUE}
  runoff_example_raw %>%
    remove_junk() %>%
    complete_dates() %>%
    head()
```

Lastly, if a seasonal or periodical analysis of the data wants to be done, these periods
can be defined with the `mark_periods` function. In the example case, the
hydrological years, going from September till August, will be defined:
```{r, purl=FALSE, eval=TRUE}
  cooked_runoff_example <- runoff_example_raw %>%
    remove_junk(.) %>%
    complete_dates(.) %>%
    mark_periods(start_month = 9, end_month = 8)
  # here is an example plot to visualise the periods
  plot(cooked_runoff_example$period,
       xlab = "Timestep",
       ylab = "# of hydrological year")
```

The example data starts with beginning of September, so right with
the first hydrological year. The end of the year 2010 is not completely inside
a hydrological year, so the period counter jumps to one.

## Code
```{r}
# ---------------------------------------------------------------------------
# Code for cooking data 
# authors: Daniel Klotz, Johannes Wesemann, Mathew Herrnegger
# !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

```
Currently the following data preperation functions can be performed from within 
**visCOS**:

- Provide example data
- Remove junk
- Prepare date formats
- Define periods

### Get Example Data
**visCOS** comes with example data, that can be used to test the available 
functions. The function to get the data is: 
```{r}
  # --------------------------------------------------------------------------
  #' Get runoff example
  #'
  #' Get exemplary runoff data to test the different functions of visCOS
  #' @export
  get_viscos_example <- function() {
    file_path <- system.file("extdata", 
                             "runoff_example.csv", 
                             package = "visCOS")
    runoff_example <- read.csv(file_path)
    return(runoff_example)
  }

```

### Remove not needed columns
This function removes all columns not specified in the `viscos_options`,
as well basins where no `data_o` is available. The function does **not** not 
distinguish between small and capital letters! Actually, **visCOS** as such 
is case insensitive. 

In teh function the `base R` function `grep` is used to get an index of the 
respective column-names. This index is then used to filter out the data and the 
function `only_observed_basins` is applied to sieve out basins where no 
observation is available (see: next sub chapter).
```{r}
  # --------------------------------------------------------------------------
  #' removes junk in cos_data
  #'
  #' Removes all columns which are not foreseen (see: viscos_options) from
  #' runoff data
  #'
  #' @import magrittr
  #' @param cos_data The cos_data data.frame (see vignette for info)
  #' @return data.frame object without the chunk
  #' @export
  remove_junk <- function(cos_data) {
    # pre: ====================================================================
    assert_dataframe(cos_data) # see: defensive code
    # determine names of cos_data and get regex: ==============================
    names_in_data <- cos_data %>% names(.)
    regex_columns <- get_regex_for_cos_data() # see: helpers
    # get idx and make clean data: ============================================
    idx <- grep(regex_columns,names_in_data, ignore.case = TRUE)
    clean_cos_data <- only_observed_basins(cos_data[ ,idx])
    return( clean_cos_data )
  }

```

#### Get only observed basins
This function removes basins that has no observations (`o_data`). Here, 
"no observations" means taht all the entries of the respective columns are either 
`NA` or tagged with the value defined with `viscos_options("missing_data")`.
```{r}
  # ---------------------------------------------------------------------------
  # remove basins without observations
  #
  # Removes basins without observation (-999/NA values) from the provided data.frame
  #
  # @param cos_data A raw cos_data data.frame, which may contains basins
  # without observations.
  # \strong{Note:} It is assumed that all available basins are simulated!
  # @return data.frame without the observation-free basins
  #
  # @import magrittr
  # @import pasta
  only_observed_basins <- function(cos_data) {
    # pre: ====================================================================
    require("magrittr")
    require("pasta")
    assert_dataframe(cos_data)
    missing_data_marker <- viscos_options("missing_data")
    # check for missing obs: ==================================================
    # set NA values to viscos_options("missing_data") and check if there are
    # cloumns wihtouth observervation:
    chosen_cols <- which( names(cos_data) != viscos_options("name_COSposix") )
    rows_with_na <- is.na(cos_data[ ,chosen_cols])
    data_wihtouth_posix <- cos_data[ ,chosen_cols]
    data_wihtouth_posix[rows_with_na] <- missing_data_marker
    colmax <- sapply(X = data_wihtouth_posix, FUN = max)
    # remove unobserved pairs: ================================================
    if ( any(colmax < 0.0) ){
      name_o <- viscos_options("name_o")
      neg_o_names <- which(colmax < 0.0) %>% names(.)
      neg_s_names <- gsub(name_o,viscos_options("name_s"), 
                          neg_o_names, 
                          ignore.case = TRUE)
      data_selection <-  paste(neg_o_names, 
                               neg_s_names, 
                               sep = "|", 
                               collapse = "|") %>% 
        grepl(names(cos_data), ignore.case = TRUE) %>%
        not(.)
      data_only_observed <- cos_data[ ,data_selection]
    } else {
      data_only_observed <- cos_data
    }
    # bonus: change missing_data to NA (useful for of computation) ============
    idx_NA <- data_only_observed %>% equals(missing_data_marker)
    data_only_observed[idx_NA] <- NA
    return(data_only_observed)
  }

```

### Complete the date formats
This function is not finished yet! All dates in **viscos** are set to *UTC* and 
hence to a **fixed time-zone** in order to avoid problems with leaps in time 
(summer/winter time). These dates have to be provided in two formats 
(see: [introduction](introduction.html)): 

1. A *five column* format: The needed-columns are year-month-day-hour-minute, 
with the names as defined in `viscos_options()`. 
2. A *one column* format: `POSIXct` (see: [link](https://stat.ethz.ch/R-manual/R-devel/library/base/html/as.POSIXlt.html)), 
and the name as defined in `viscos_options("name_COSposix")`.

The idea of `complete_dates` is to provide a internal method to get one fromat 
out of the other. **However**, currently it is only possible to convert 
the 5-columns representation into `POSIXct` dates via the internally defined
`implode_cosdate` function. So - without further ado - here is the function 
```{r}
  # ---------------------------------------------------------------------------
  #' Complete the date-formats with POSIXct or COSdate
  #'
  #' Complete the data-formats of your data.frame `POSIXct` and/or `COSdate`
  #'
  #' @param cos_data The data.frame, which contains the runoff information
  #' @param name_cosyear string with the name of the `COSdate` year column
  #' @param name_posix string with the name of the POSIXct column
  #' @return The new runoff data.frame with the added data-format.
  #'
  #' @import magrittr
  #'
  #' @export
  complete_dates <- function(cos_data) {
    # pre: ==================================================================== 
    assert_dataframe(cos_data) 
    date_names <- unlist(viscos_options("name_COSyear", 
                                        "name_COSmonth", 
                                        "name_COSmonth", 
                                        "name_COShour", 
                                        "name_COSmin")
                        )
    # check dates: ============================================================
    # stop if non-logical expression are obtained
    all_dates_in_cosdata <- any( date_names %in% names(cos_data) )
    posix_cosdata <- any(viscos_options("name_COSposix") == names(cos_data))
    if ( !is.logical(all_dates_in_cosdata) | !is.logical(posix_cosdata) ) {
      stop("Something is wrong :( \n
            Some of the date-columns could not be processed!")
    }
    # execute function for the available format: ==============================
    if (!all_dates_in_cosdata & !posix_cosdata) {
      stop("Something is wrong :( \n
           The 5 cosero date columns and the POSIXct colum could not be found")
    } else if (all_dates_in_cosdata & !posix_cosdata) {
      cos_data <- implode_cosdate(cos_data) # see: sub-chapter Implode date
    } else if (!all_dates_in_cosdata & posix_cosdata) {
      stop("POSIXct to COSdates not yet supported :(")
    }
    return(cos_data)
  }

```

#### Implode date
This sub-function is used to transform the "old-school" 5 column format into the 
modern `POSIXct`. 
```{r}
  # ---------------------------------------------------------------------------
  implode_cosdate <- function(cos_data) {
    # pre: ==================================================================== 
    require("magrittr", quietly = TRUE)
    require("pasta", quietly = TRUE)
    assert_dataframe(cos_data)
    name_string <- cos_data %>% names(.) %>% tolower(.)
    # create posix_date column: ===============================================
    month_digits <- sprintf("%02d",cos_data[[viscos_options("name_COSmonth")]])
    day_digits <- sprintf("%02d",cos_data[[viscos_options("name_COSday")]])
    hour_digits <- sprintf("%02d",cos_data[[viscos_options("name_COShour")]])
    minute_digits <- sprintf("%02d",cos_data[[viscos_options("name_COSmin")]])
    posix_date <- cos_data[[viscos_options("name_COSyear")]] %&% 
        month_digits %&% 
        day_digits %&% 
        hour_digits %&% 
        minute_digits %>%
      as.POSIXct(format = "%Y%m%d%H%M",
                 origin = .[1],
                 scale = "hourly",
                 tz = "UTC")
    cos_data[[viscos_options("name_COSposix")]] <- posix_date
    return(cos_data)
  }

```

### Remove leading zeros in column names
This internal function removes leading zeros from column names of the
`cos_data` data.frame.
The function has no defensive code but uses `remove_junk` (see: above).
It should therefore be used with care!
```{r}
  # ---------------------------------------------------------------------------
  # remove leading zeros from the names of cos_data (data.frame)
  remove_leading_zeros <- function(cos_data) {
    # pre: ====================================================================
    require("magrittr", quietly = TRUE)
    require("pasta", quietly = TRUE)
    cos_data %<>% remove_junk
    name_o <- viscos_options("name_o")
    search_o_or_s <- paste0(name_o,"|", viscos_options("name_s"))
    runoff_names <- cos_data %>% names(.)
    runoff_lowercase_names <- runoff_names %>% tolower(.)
    del_leading_zeros <- function(string) sub("^[0]+", "",string)
    # calc: ===================================================================
    idx_o <- grep(name_o , runoff_lowercase_names)
    separator <- runoff_lowercase_names %>%
      extract( idx_o[1] ) %>%
      gsub(name_o, "", .) %>%
      gsub("\\d", "", .)
    runoff_nums <- runoff_lowercase_names %>%
      gsub(search_o_or_s, "",.) %>%
      gsub(separator, "", .) %>%
      gsub("\\D", "", .)
    search_runoff_nums <- "[" %&% paste(runoff_nums, collapse = "") %&% "]"
    runoff_only_names <- runoff_names %>%
      gsub(search_runoff_nums, "", .) %>%
      gsub(separator,"",.)
    # clean up: ===============================================================
    runoff_new_numbers <- del_leading_zeros(runoff_nums)
    new_names <- runoff_new_numbers %>%
      gsub("\\d+", separator,.) %>%
      paste0(runoff_only_names, ., runoff_new_numbers)
    names(cos_data) <- new_names
    return(cos_data)
  }

```


### Mark the needed periods
This function creates a period column. The period column consists of
increasing integers for each period. Rows with zeros are considered to be 
out-of-period. The names of the period column is defined with 
`viscos_options("name_COSperiod")`. 

The function has three inputs: The data.frame `cos_data` and the two 
integers `start_month` and `end_month`. The latter define the to-be monhts that 
are within the period. Everything between `start_month` and `end_month` is 
consideren to be in-period. 

Here are two  examples that display the slected periods and the
numbering:
```{r, eval=TRUE, purl=FALSE}
  require(magrittr)
  require(visCOS)
  # example 1: hydrological years (september till august)
  ex1 <- get_viscos_example() %>% mark_periods(start_month = 9, end_month = 8)
  plot(ex1$period, xlab = "Timestep", ylab = "# of hydrological year")
  # note that the last year is not complete, so the counter jumps back to 0
  
  # example 2: summer months (june till august)
  ex2 <- get_viscos_example() %>% mark_periods(start_month = 6, end_month = 8)
  plot(ex2$period, xlab = "Timestep", ylab = "# year of summer months")
```

This is currently computed in the following way: 

Before starting the acutal computation the variables `period_range` and 
`out_of_period` are defined. The `period_range` are the months ordered in the 
given range. The `out_of_period` variable marks all months which are not within
the chosen period. With these variables the periods can be "marked" in two 
steps:

1. All the starting months within cos_data are marked and the cumulative
sum is used to count the periods within the data.frame. At the
beginning of the first period, the counter is at "1" and becomes "2" with the
beginning of the second period and so on.
2. The `out_of_period` of all years is set back to zero again by
checking which months of the data are equal to the `out_of_period` entries.

One problem with this solution is that the last year is not extracted properly
if the `start_month`is higher than the `end_month`. To compensate this problem 
the `dplyr` shenanigans are added as an inofficial third step. 
Another quirk is, that with this solution the the first and last period are 
included, even if they are not complete.

This solution is not realy satisfying. But, life is short and it at 
the time it seemed to be the best that the authors could come out with. 
Suggestions for improvements are welcome! 
```{r}
  # ---------------------------------------------------------------------------
  #' calculate periods
  #'
  #' Mark the periods within cos_data.
  # The marking uses a monthly resolution, which are defined by the integers
  #' `start_month` and `end_month`.  
  #'
  #' @param cos_data The data.frame, which contains the runoff information
  #' @return The runoff data.frame reduced and ordered according to the
  #' hydrological years within the data.
  #' \strong{Note:} The periods columns are formatted as characters!
  #'
  #' @import dplyr
  #' @import magrittr
  #'
  #' @export
  mark_periods <- function(cos_data, start_month = 10, end_month = 9) {
    # pre: ====================================================================
    assert_dataframe(cos_data)
    name_year <- viscos_options("name_COSyear")
    name_month <- viscos_options("name_COSmonth")
    cos_data %<>% remove_junk %>% complete_dates()
    eval_diff <- function(a) {c(a[1],diff(a))}
    # calc: ===================================================================
    # (I) get labels for the months: 
    if (start_month <= end_month ) {
      period_range <- seq(start_month,end_month)
      out_of_period <- seq(1,12) %>% extract( !(seq(1,12) %in% period_range) )
    } else if (start_month > end_month) {
      range_1 <- seq(start_month,12)
      range_2 <- seq(1,end_month)
      period_range <- c(range_1,range_2)
      out_of_period <- seq(1,12) %>% extract( !(seq(1,12) %in% period_range) )
    }
    # (II) mark periods: 
    start_months_in_data <- cos_data[[name_month]] %in% c(start_month)
    cos_data[[viscos_options("name_COSperiod")]] <- start_months_in_data %>%
      eval_diff() %>%
      pmax(.,0) %>%
      cumsum
    out_period_in_data <- cos_data[[name_month]] %in% out_of_period
    cos_data$period[out_period_in_data] <- 0
    # (III) corrections for last year 
    max_year <- max(cos_data[[name_year]])
    marked_cos_data <- cos_data %>% 
      dplyr::mutate(
        period = ifelse(
          ((.[[name_year]] == max_year) &  (.[[name_month]] > end_month)),
          0,
          period)
      )
    return(marked_cos_data)
  }

```

### Transform the `cos_data` into `xts`
This function is just a small wrapper around the `xts()` function for internal 
use in **viCOS**. 

A notable quirk of the function is it puts all column-names to lower cases and 
removes leading zeros in their enumeration.
```{r}
  # ---------------------------------------------------------------------------
  #' Convert cos_data to xts-format
  #'
  #' Converts the cos_data (class: data_frame) into an xts object
  #'
  #' @param cos_data data_frame of the cos_data (see: xxx)
  #' @return xts object of the cos_data data.frame
  #'
  #' @import zoo
  #' @importFrom xts xts
  #' @import magrittr
  cos_data_as_xts <- function(cos_data) {
    # pre: ====================================================================
    assert_dataframe(cos_data)
    assert_junk(cos_data)
    assert_complete_date(cos_data)
    # calc: ===================================================================
    # set every- name to lover capitals and generate xts frame
    new_names <- names(cos_data) %>% tolower
    name_posix <- viscos_options("name_COSposix") %>% tolower
    cos_data <- remove_leading_zeros(cos_data) %>%
      magrittr::set_names(new_names)
    cos_data_as_xts <- xts(x = cos_data[], order.by = cos_data[[name_posix]])
    return(cos_data_as_xts)
  }
```
