---
title: "Cook Data"
author: "Daniel Klotz"
date: "6 Juli 2016"
output: 
  html_document:
    number_sections: yes
---
```{r setup, include=FALSE, purl=FALSE}
knitr::opts_chunk$set(eval = FALSE, tidy = FALSE)
```

# Data Kitchen
Here functions are collected that deal with the process of transforming 
*rawdata* into usefull data for **visCOS**. 
Processed data is then *cooked data* and can be used for figures etc. 

## Obtaining raw data 
From the point of view of **visCOS** raw-data are time-series of observations 
and model output. Usually raw data is saved in some simple file format,
e.g. *.txt* or *.csv*. `R` allready includes many option to read those files 
with the `read.table` functionalities.
For larger unstructured files the read options of the `data.table` package is 
recommended. In our tests it was fastest and most flexible option. 
Altenratively the 'readr' can be used if the data is more structured and large.

The function `get_runoff_example` can be used to get some exemplary data 
from within **visCOS**:
```{r, eval = TRUE, purl = FALSE}
  library(visCOS)
  runoff_example <- get_runoff_example()
  head(runoff_example)
```


# Code
This chapter documents the code from the different visCOS functions

## `get_runoff_example`
visCos porvides some exemplary data. All the available functions are tested 
with those. `get_runoff_example` is a small wrapper function to get the data from 
within the package via `read.csv`
```{r}
  #' Get runoff example
  #' 
  #' Get exemplary runoff data to test the different functions of visCOS
  #' @export
  get_runoff_example <- function() {
    file_path <- system.file("extdata", 
                             "runoff_example.csv", 
                             package = "visCOS")
    runoff_example <- read.csv(file_path)
    return(runoff_example)
  }
```

## `remove_chunk` 
This function removes all columns not specified in the `viscos_options` string
`data_regex`, aswell basins where no observations are available.
The first part is done by identifying the names of the data_frame and 
searching for the idx of the names defined in the regular expression string. 
The second part is done via the function prepare.only_observed (see next subchapter).
It is actually so pretty simple, but realy usefull. Since the solution is 
quite specific the function tests if the input is a data.frame and returns an 
error if not. 

**Note** that the routine is **not** case sensitive. It does not distinguish 
inbetween small and capital letters!

The function header is: 
```{r}
  #' removes chunk in runoff_data
  #' 
  #' Remove all collumns which are not foreseen (see: viscos_options) from 
  #' runoff data 
  #' 
  #' @param runoff_data data.frame object containing at lesast COSdate, 
  #' Qsim and Qobs (see: xxx)
  #' @return data.frame object withouth the chunk
  #' @export
  remove_chunk <- function(runoff_data) {
```

The first part of the code loads the dependencies and makes sure that the 
runoff_data varibale is a data.frame: 
```{r}
  require("magrittr", quietly = TRUE)
  # 
  if ( !is.data.frame(runoff_data) ){
    stop("Input Data must be a data.frame object")
  } 
```

The operation works as following. First, the names of the names of the 
runoff_data are determines via `names` and set to all lower letters with 
`tolower`. This is the reason why the function is not case sensitive!
Then `viscos_options` is called to get the names of the 8 allowed column names
and pasted into a regex string (`regex_columns`). Then `grep` is used to get 
the index `idx` of the columns with the given names (`lowercase_names_in_data`). 
Finally, `idx`is then used to select the wanted columns.  
```{r}
  lowercase_names_in_data <- runoff_data %>% names %>% tolower 
  # 
  regex_columns <- paste("^",viscos_options()$name_COSyear,"$|", 
                         "^",viscos_options()$name_COSmonth,"$|",
                         "^",viscos_options()$name_COSday,"$|",
                         "^",viscos_options()$name_COShour,"$|",
                         "^",viscos_options()$name_COSmin,"$|",
                         viscos_options()$name_COSobs,".*|",
                         viscos_options()$name_COSsim,".*|",
                         viscos_options()$name_COSposix,"|",
                         viscos_options()$name_COSperiod,
                         sep = "")

  idx <- regex_columns %>% 
    grep(.,lowercase_names_in_data)
    no_chunk_runoff_data <- runoff_data[ , idx]
    return( only_observed_basins(no_chunk_runoff_data) )
  }
```

### `only_observed_basins`
This function removes basins for which no observations are available. No 
observation are interpreted as columns in which the all entries are either -999
or `NA's`. The function header looks like this: 
```{r}
# remove basins withouth observations
#
# Removes basins withouth observation (-999/NA values) from the provided dataframe
#
# @param runoff_data A raw runoff_data data.frame, which may containts basins 
# withouth observations.
# \strong{Note:} It is assumed that all available basins are simulated!
# @return data.frame without the observation-free basins
# @export
only_observed_basins <- function(runoff_data) {
```

As so often it is first checked if `magrittr` is available. 
Afterwards, it is asserted that `runoff_data` is indeed a data frame 
(see the chapter about defensive code). With that the preperations are finished, 
which should be fine as the function is supposedly only called from within 
`remove_chunk`. 
```{r}
  require("magrittr", quietly = TRUE)
  assert_dataframe(runoff_data)
```

In order to handle the `NA's` and -999 in the same way all `NA's` are replaced 
with -999. Then the `lapply` function is used to find the max of each column. 
```{r}
  runoff_data[is.na(runoff_data)] <- -999 
  colmax <- lapply(X = runoff_data, FUN = max) # get max of any column
```

If any column has a max of -999 it is worth futher investigation.
Unfortunately the -999 columns could also mean, that something went wrong 
with the simulation, thus one has to make sure that only obsevation columns 
are selected. To do so we first identify the idx of the max == -999 cols and 
build a regular expression with the help of the `viscos_options`.
We combine both infromation via `grepl` to check if only observed columns have
been selected. If so everything is fine, but if `any` of the selected cols came
from an observation col the function stops the execution and gives a warning 
message. 
The next step involves a little trick in which +1 is added to the `idx` to 
obtain the indexes of the corresponding simulation. Here we assume that for each
observation there is a corresponding simulation **in next the next colum**!
This allows us then to select only the observed basins. But now all NA values 
are actually -999! Thus, we replace them again back to NA, via `lapply(...,min)`
assuming that all negative values are NAs. This is not a strong assumation, 
because there should never be negative flows! In the end the resulting
data.frame is returned.
```{r}
  if ( any(colmax < 0.0) ){
    idx_temp <- which(colmax < 0.0) 
    obs_regex <- paste(viscos_options()$name_COSobs,".*", sep ="")
    OnlyQobsSelected <- idx_temp %>%
      names %>% 
      tolower %>%
      grepl(obs_regex,.) %>%
      any
    if (!OnlyQobsSelected){
      stop("There are Qsim withouth simulation (i.e. only values smaller 0). Pls remove them first")
    }
```

```{r}
    idx_slct <- c(idx_temp,idx_temp + 1) %>% sort() 
    d_onlyObserved <- runoff_data[-idx_slct]
    # set remaining negative Qobs to NA, so that HydroGOF can be used correctly, also ignoring NAs
    colmin <- lapply(X = d_onlyObserved, FUN = min)
    idx_temp <- which(colmin < 0.0) 
    d_onlyObserved[d_onlyObserved[idx_temp]<0, idx_temp] <- NA
    return(d_onlyObserved)
  } else {
    return(runoff_data)
  }
}


```

## `prepare.complete_date` 
This function is a wrapper. It is however not finished yet! 
The idea is the following. The idea is to provide a handy function to complete 
the date-columns. Within the data.frame the user has to provide either 5 columns 
with the *COSdate* format: `yyyy-mm-dd-hh-min` i.e.: year-month-day-hour-minute or 
an equivalent column in `POSIXct` format 
(see: [link](https://stat.ethz.ch/R-manual/R-devel/library/base/html/as.POSIXlt.html)).

*However*, it is currently only possible to convert *COSdate* into `POSIXct` dates
via the `implode_cosdate` function. 

The function itself is basically a switch which calls different functions, 
if `name_cosyear` and/or `name_posix` is found and returns an error if none of 
the two are found. If the user has not named his columnds according to COSERO 
convention he can provide the names of the *COSdate* year via `name_cosyear` and
the names of the POIXct column via `name_posix`. The function returns an error 
if `runoff_data` is not a data frame and if `OK_COSdate` or `OK_POSIXdates` are
not logical due to some problems with the dates/time-formats. 

A *caveat* with this method is that only the `name_cosyear` is checked to infer 
if the 5 *COSdate* columns are available. This can cause errors later if some 
other columns are missing. Sadly it is not apparent how to avoid that problem,
withouth defining the names of all columns. 

Furthermore, please we need to be aware that a fixed that the time-zone is 
assumed to be *UTC* to avoid problems with leaps in time (summer/winter time).
```{r}
#' Complete the date-formats with POSIXct or COSdate
#' 
#' Complete the data-formats of your data.frame `POSIXct` and/or `COSdate`
#' 
#' @param runoff_data The data.frame, which contains the runoff information
#' @param name_cosyear string with the name of the `COSdate` year column
#' @param name_posi string with the name of the POSIXct column 
#' @return The new runoff data.frame with the added data-format. 
#' @export
prepare.complete_date <- function(runoff_data = NULL, 
                                  name_cosyear = "yyyy",
                                  name_posix = "POSIXdate") {
```

```{r}
  # 1. make sure that magrittr is loaded: 
  require("magrittr", quietly = TRUE)
  # 2. check if the runoff_data is a data.frame
  if ( !is.data.frame(runoff_data) ) stop("runoff_data is no data_frame!")
  # 3. Check for COSdates and stop if non-logical expression are obtained
  OK_COSdate <- any(names(name_cosyear)=="yyyy")
  OK_POSIXdates <- any(names(name_posix)=="POSIXdate")
  if ( !is.logical(OK_COSdate) | !is.logical(OK_POSIXdates) ) {
    stop("Something seems to be wrong with the date / time formats :(")
  }
```

To function `implode_cosdate` is used to obtain the POSIXct date from the 
*COSdate* columns. The following chapter will show how this is done. 
```{r}
  # choose function depending on which formats are available!
  if (!OK_COSdate & !OK_POSIXdates) {
    stop("No COSdates and no POSIXct-dates in the data!")
  } else if (OK_COSdate & !OK_POSIXdates) { 
    runoff_data <- implode_cosdate(runoff_data) # see following chapter
  } else if (!OK_COSdate & OK_POSIXdates) {
    stop("POSIXct to COSdates not yet supported :(")
  }
  return(runoff_data)
}
```

### `implode_cosdate`
This function is used to transform the old-school *COSdate* format into the 
widely spread POSIXct format, used within R and in many packages. The function 
is called by the function above and not provided to the user! It takes a 
data frame (`runoff_data`) and uses `viscos_options` to transfrom the different
*COSdate* columns into POSIXct dates via `paste`. 
The function header is: 
```{r}
# transform COSdate into the nicer POSIXct-date format
#
# Takes a data.frame, which contains the COSdate format (see: xxx) and 
# transforms it into a POSIXct series. Note that time is assumed to be in UTC
implode_cosdate <- function(runoff_data) {
```

The following sanity checks are applied: 
(I) A check is made if magrittr is loaded or can be loaded. 
(II) A test is made to check if `runoff_data` is a `data.frame`. 
(III) The column names are obtained and it is tested if the POSIXdate column, 
defined by `viscos_options` is allready existend. If yes, the function stops.
of the data.frame are loaded 
```{r}
  require("magrittr", quietly = TRUE)
  # 
  if ( !is.data.frame(runoff_data) ) stop("runoff_data is no data_frame!")
  #
  name_string <-  runoff_data %>% names %>% tolower
  if (any(name_string == viscos_options()$name_COSposix)) stop("runoff_data does allreay contain POSIXdate")
```

```{r}
  POSIXdate <- paste(runoff_data[viscos_options()$name_COSyear],
                     sprintf("%02d",runoff_data[viscos_options()$name_COSmonth]),
                     sprintf("%02d",runoff_data[viscos_options()$name_COSday]),
                     sprintf("%02d",runoff_data[viscos_options()$name_COShour]),
                     sprintf("%02d",runoff_data[viscos_options()$name_COSmin]),
                     sep= "" ) %>%
    as.POSIXct(format = "%Y%m%d%H%M",tz = "UTC")
  return(cbind(runoff_data,POSIXdate))
}
```

## `remove_leading_zeros`
This function removes leading zeros from column names of the data.frame 
`runoff_data`.The function has no defensive codidng, appart from the execution 
of `remove_chunk` (see corresponding chapter) to be sure that no non-needed 
columns are within the data.frame. 
```{r}

remove_leading_zeros <- function(runoff_data) {
  require("magrittr", quietly = TRUE)
  runoff_data <- remove_chunk(runoff_data)
```

The body of the function works in the following way:
The variables `runoff_names` ist computed by obtaining the names of the columns 
of `runoff_data` are obtained with `names` and removing all teh digits with 
`gsub("\\d",...)`. The basin digits, `runoff_nums` are computed by doing the 
oposite, i.e.: removing all the non digits via `gsub("\\D",...)`. Afterwards, 
the empty strings ("") are replaced with a small trick: The characters are 
transformed into a numerics (induces `NA's`) and back again. 
In the last step the variables `runoff_names` and `runoff_nums` are simply put
togehter again via the paste command. The result has no leading zeros as in the 
variable numeration. 
```{r}
  runoff_names <- runoff_data %>% names %>% gsub("\\d","",.) 
  # get numbers and remove leading zeros
  runoff_nums <- runoff_data %>% 
    names %>% 
    gsub("\\D","",.) %>% 
    as.numeric %>%  
    as.character
  runoff_nums[is.na(runoff_nums)] = ""
  # paste new nums as new data_names 
  names(runoff_data) <- paste(runoff_names, runoff_nums, sep = "")
  return(runoff_data)
}
```
