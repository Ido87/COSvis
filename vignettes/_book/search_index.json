[
["index.html", "visCOS: documentation Hello, traveler", " visCOS: documentation Daniel Klotz, Johannes Wesemann, Mathew Herrnegger Hello, traveler visCOS (visual comparison of observations and simulations) is still under (heavy) development. It is thus not recommended to use the package, yet. There exist many hydrological R-packages. Among them there are several that have the goal of providing aid to the calibration of hydrological models. In particular: The hydroGOF packages provides a set of commonly used (and disputed) objective functions. The hydroTSM package allows for the analysis, interpolation and plotting of hydrological time series. Topically, visCOS can be positioned between those two. In concrete, visCOS is an R-package that provides summaries and visualisation to aid the parameter estimation for conceptual rainfall-runoff models in general and COSERO in special. COSERO is a HBV-like model that was developed at the institute for water management, hydrology and hydraulic engineering (IWHW) at BOKU, Vienna. The name is an abbreviation for “Conceptual Semi-Distributed Rainfall Runoff Model”. This page provides a hub to access the different examples and the entire program code. "],
["cook-data.html", "1 Cook Data 1.1 The basic data structure 1.2 Loading raw data 1.3 Examples 1.4 Code", " 1 Cook Data Within visCOS “cooking data” is is used as a synonym for the process of transforming raw data into cooked data, that is data in the COSERO data.frame format. The cooked data can then be used for figures and other things. The package already provides a set of basic functions for that task that were useful for the applications at the institute. This section defines these functions and explains their usage. Currently the following steps can be performed from within visCOS_ Provide example data Remove junk Prepare date formats Define periods 1.1 The basic data structure Shall follow 1.2 Loading raw data From the point of view of visCOS raw-data are time-series of observations and model output. Usually raw data is saved in some simple file format, e.g. .txt or .csv. R already includes many option to read those files with the read.table functionalities. For larger unstructured files the read options of the data.table package is recommended. In our tests it was fastest and most flexible option. Alternatively the readr can be used if the data is more structured and large. Note at this stage, only a comparison between numbered catchments for two parameters is possible. So the data must include an integer number after the description (like “QObs_001” and “QSim_001”). 1.3 Examples The function get_cos_data_example can be used to get some exemplary data from within visCOS: library(visCOS) require(magrittr) options(width=80) runoff_example_raw &lt;- get_cos_data_example() head(runoff_example_raw) ## yyyy mm dd hh min QOBS_0001 QOSI_0001 QSIM_0001 QOBS_0002 QOSI_0002 QSIM_0002 ## 1 2007 1 1 0 0 2.98 3.48 3.48 2.56 3.11 3.11 ## 2 2007 1 1 1 0 2.89 3.48 3.48 2.56 3.11 3.11 ## 3 2007 1 1 2 0 2.64 3.48 3.48 2.57 3.11 3.11 ## 4 2007 1 1 3 0 2.51 3.48 3.48 2.57 3.11 3.11 ## 5 2007 1 1 4 0 2.42 3.48 3.48 2.57 3.11 3.11 ## 6 2007 1 1 5 0 2.34 3.49 3.49 2.57 3.11 3.11 The next step would be to adapt the options (viscos_options, but in this case the options are already set as in the data: viscos_options() %&gt;% unlist() ## name_o name_s data_unit name_COSyear name_COSmonth ## &quot;qobs&quot; &quot;qsim&quot; &quot;(m^3/s)&quot; &quot;yyyy&quot; &quot;mm&quot; ## name_COSday name_COShour name_COSmin name_COSposix name_COSperiod ## &quot;dd&quot; &quot;hh&quot; &quot;min&quot; &quot;posixdate&quot; &quot;period&quot; ## missing_data color_o color_s of_limits1 of_limits2 ## &quot;-999&quot; &quot;steelblue&quot; &quot;orange&quot; &quot;0&quot; &quot;1&quot; However, a glimpse of the data above shows that some of the columns (QOSI_0001 and QOSI_0002) are not needed for the analysis. All the junk data, i.e. data columns that are not defined within the options and unobserved columns can be removed using the remove_junk function. Additionally visCOS needs to have two different ways to define the date of a given row (see: Introduction). In the runoff_example each part of the date definition is defined with a column: “yyyy” - year, “mm” - month, “hh” - hour, “min” - minute. The other needed format is the POSIXctformat (see: [link](https://stat.ethz.ch/R-manual/R-devel/library/base/html/as.POSIXlt.html)) format often used within R. Here all the information is saved within one column Given one date format is available in the data.frame the other can be generated by usingcomplete_dates`. runoff_example_raw %&gt;% remove_junk() %&gt;% complete_dates() %&gt;% head() ## yyyy mm dd hh min QOBS_0001 QSIM_0001 QOBS_0002 QSIM_0002 posixdate ## 1 2007 1 1 0 0 2.98 3.48 2.56 3.11 2007-01-01 00:00:00 ## 2 2007 1 1 1 0 2.89 3.48 2.56 3.11 2007-01-01 01:00:00 ## 3 2007 1 1 2 0 2.64 3.48 2.57 3.11 2007-01-01 02:00:00 ## 4 2007 1 1 3 0 2.51 3.48 2.57 3.11 2007-01-01 03:00:00 ## 5 2007 1 1 4 0 2.42 3.48 2.57 3.11 2007-01-01 04:00:00 ## 6 2007 1 1 5 0 2.34 3.49 2.57 3.11 2007-01-01 05:00:00 Lastly, if a seasonal or periodical analysis of the data wants to be done, these periods can be defined with the mark_periods function. In the example case, the hydrological years, going from September till August, will be defined: cooked_runoff_example &lt;- runoff_example_raw %&gt;% remove_junk() %&gt;% complete_dates() %&gt;% mark_periods(., start_month = 9, end_month = 8) # here is an example plot to visualise the periods plot(cooked_runoff_example$period, xlab = &quot;Timestep&quot;, ylab = &quot;# of hydrological year&quot;) Note that the example data starts with beginning of September, so right with the first hydrological year. The end of the year 2010 is not completely inside a hydrological year, so the period counter jumps to one. 1.4 Code This function defines the data cooking functions. 1.4.1 Get Example Data visCOS provides some exemplary data. All the available functions can be tested with it. get_cos_data_example is a small wrapper function to get the data from within the package via read.csv Note at this stage, only a comparison between numbered catchments is possible for two parameters is possible. So the data must include an integer number after the description (like “QObs_001” and “QSim_001”) #&#39; Get runoff example #&#39; #&#39; Get exemplary runoff data to test the different functions of visCOS #&#39; @export get_cos_data_example &lt;- function() { file_path &lt;- system.file(&quot;extdata&quot;, &quot;runoff_example.csv&quot;, package = &quot;visCOS&quot;) runoff_example &lt;- read.csv(file_path) return(runoff_example) } 1.4.2 Remove not needed columns This function removes all columns not specified in the viscos_options, as well basins where no data_o is available. Note that the routine is not case sensitive. It does not distinguish between small and capital letters! The first part of the code loads the dependencies and makes sure that the cos_data variable is a data.frame (see: chapter about defensive coding). The body of remove_junk works as following: First, the names of the columns of the cos_data are determined and helper function get_regex_for_cos_data is invoked to get regular expressions for the columns defined within viscos_otopns. Then the idx of the different wanted data is extracted and used to select the appropriate columns. Afterwards, the “sub” function only_observed_basins is being executed (see next chapter) #&#39; removes junk in cos_data #&#39; #&#39; Removes all columns which are not foreseen (see: viscos_options) from #&#39; runoff data #&#39; #&#39; @import magrittr #&#39; @param cos_data The cos_data data.frame (see vignette for info) #&#39; @return data.frame object without the chunk #&#39; @export remove_junk &lt;- function(cos_data) { assert_dataframe(cos_data) # names_in_data &lt;- cos_data %&gt;% names regex_columns &lt;- get_regex_for_cos_data() # see: helpers # idx &lt;- regex_columns %&gt;% grep(.,names_in_data, ignore.case = TRUE) no_junk_cos_data &lt;- cos_data[ , idx] return( only_observed_basins(no_junk_cos_data) ) } 1.4.2.1 Get only observed basins This function removes basins for which no data in the o_data column. No observation are columns where all the entries are either as defined in viscos_options(&quot;missing_data&quot;) or NA's. At the end of the function the former are transformed into NA's. # remove basins without observations # # Removes basins without observation (-999/NA values) from the provided data.frame # # @param cos_data A raw cos_data data.frame, which may contains basins # without observations. # \\strong{Note:} It is assumed that all available basins are simulated! # @return data.frame without the observation-free basins # # @import magrittr # @import pasta only_observed_basins &lt;- function(cos_data) { require(&quot;magrittr&quot;) require(&quot;pasta&quot;) assert_dataframe(cos_data) # set NA values to viscos_options(&quot;missing_data&quot;) and check if there are # cloumns wihtouth observervation chosen_cols &lt;- which( names(cos_data) != viscos_options(&quot;name_COSposix&quot;) ) rows_with_na &lt;- is.na(cos_data[,chosen_cols]) data_wihtouth_posix &lt;- cos_data[ ,chosen_cols] data_wihtouth_posix[rows_with_na] &lt;- viscos_options(&quot;missing_data&quot;) colmax &lt;- sapply(X = data_wihtouth_posix, FUN = max) # # if there are columns withouth observations remove them from the data: if ( any(colmax &lt; 0.0) ){ name_o &lt;- viscos_options(&quot;name_o&quot;) neg_o_names &lt;- which(colmax &lt; 0.0) %&gt;% names neg_s_names &lt;- gsub(name_o,viscos_options(&quot;name_s&quot;),neg_o_names,ignore.case = TRUE ) data_selection &lt;- neg_o_names %|% neg_s_names %&gt;% paste(.,collapse = &quot;|&quot;) %&gt;% grepl(., names(cos_data), ignore.case = TRUE) %&gt;% not(.) data_only_observed &lt;- cos_data[ ,data_selection] } else { data_only_observed &lt;- cos_data } # set all missing data values to NA for use in hydroGOF idx_NA &lt;- data_only_observed %&gt;% equals(viscos_options(&quot;missing_data&quot;)) data_only_observed[idx_NA] &lt;- NA return(data_only_observed) } 1.4.3 Complete the date formats This function is not finished yet! Within cos_data data.frame (see: introduction) the date has to be defined in two formats: With 5 columns, where the columns are year-month-day-hour-minute and names as defined in viscos_options() and with one column in POSIXct format (see: link), that is named as defined in viscos_options(&quot;name_COSposix&quot;). The idea of the complete_dates fucntion is to provide a internal posibility to create the one format out of the ohter and thus complete the dates. However, currently it is only possible to convert the 5-columns representation into POSIXct dates via the internally defined implode_cosdate function. Also by using UTC a fixed time-zone is assumed within visCOS to avoid problems with leaps in time (summer/winter time). #&#39; Complete the date-formats with POSIXct or COSdate #&#39; #&#39; Complete the data-formats of your data.frame `POSIXct` and/or `COSdate` #&#39; #&#39; @param cos_data The data.frame, which contains the runoff information #&#39; @param name_cosyear string with the name of the `COSdate` year column #&#39; @param name_posix string with the name of the POSIXct column #&#39; @return The new runoff data.frame with the added data-format. #&#39; #&#39; @import magrittr #&#39; #&#39; @export complete_dates &lt;- function(cos_data) { # make sure that magrittr is loaded: assert_dataframe(cos_data) # check for COSdates and stop if non-logical expression are obtained OK_COSdate &lt;- any( unlist(viscos_options(&quot;name_COSyear&quot;, &quot;name_COSmonth&quot;, &quot;name_COSmonth&quot;, &quot;name_COShour&quot;, &quot;name_COSmin&quot;) ) %in% names(cos_data) ) OK_POSIXdates &lt;- any(names(cos_data) == viscos_options(&quot;name_COSposix&quot;)) if ( !is.logical(OK_COSdate) | !is.logical(OK_POSIXdates) ) { stop(&quot;Something is wrong :( \\n some of the date-columns could not be processed!&quot;) } # choose function depending on which formats are available! if (!OK_COSdate &amp; !OK_POSIXdates) { stop(&quot;Something is wrong :( \\n The 5 cosero date columns and the POSIXct colum could not be found&quot;) } else if (OK_COSdate &amp; !OK_POSIXdates) { cos_data &lt;- implode_cosdate(cos_data) # see following chapter } else if (!OK_COSdate &amp; OK_POSIXdates) { stop(&quot;POSIXct to COSdates not yet supported :(&quot;) } return(cos_data) } 1.4.3.1 Implode cosdate This function is used to transform the “old-school” 5 column format into the widely spread POSIXct format. The function is not exported and should only be called from within complete_date()!. Also, thanks to Christoph Schürz for his help with conception. implode_cosdate &lt;- function(cos_data) { require(&quot;magrittr&quot;, quietly = TRUE) assert_dataframe(cos_data) name_string &lt;- cos_data %&gt;% names %&gt;% tolower # POSIXdate &lt;- paste(cos_data[[viscos_options(&quot;name_COSyear&quot;)]], sprintf(&quot;%02d&quot;,cos_data[[viscos_options(&quot;name_COSmonth&quot;)]]), sprintf(&quot;%02d&quot;,cos_data[[viscos_options(&quot;name_COSday&quot;)]]), sprintf(&quot;%02d&quot;,cos_data[[viscos_options(&quot;name_COShour&quot;)]]), sprintf(&quot;%02d&quot;,cos_data[[viscos_options(&quot;name_COSmin&quot;)]]), sep= &quot;&quot; ) %&gt;% as.POSIXct(format = &quot;%Y%m%d%H%M&quot;, origin = .[1], scale = &quot;hourly&quot;, tz = &quot;UTC&quot;) cos_data[[viscos_options(&quot;name_COSposix&quot;)]] &lt;- POSIXdate return(cos_data) } 1.4.4 Remove leading zeros in column names This internal function removes leading zeros from column names of the cos_data data.frame. The function has no defensive code but uses remove_junk (see: above). It should therefore be used with care! Sad Note: The current solution is bit suboptimal as many operations are needed and different tricks are used (e.g. as.numeric %&gt;% as.character) to obtain the wanted result. We hope that better solutions can be found in the future. # remove leading zeros from the names of cos_data (data.frame) remove_leading_zeros &lt;- function(cos_data) { require(&quot;magrittr&quot;, quietly = TRUE) cos_data %&lt;&gt;% remove_junk # runoff_names &lt;- cos_data %&gt;% names runoff_lowercase_names &lt;- runoff_names %&gt;% tolower # separator &lt;- runoff_lowercase_names %&gt;% extract( grep(viscos_options()$name_o,.) ) %&gt;% extract( 1 ) %&gt;% gsub(viscos_options()$name_o,&quot;&quot;,.) %&gt;% gsub(&quot;\\\\d&quot;,&quot;&quot;,.) searchterm &lt;- paste0(viscos_options()$name_o,&quot;|&quot;, viscos_options()$name_s) runoff_nums &lt;- runoff_lowercase_names %&gt;% gsub(searchterm,&quot;&quot;,.) %&gt;% gsub(separator,&quot;&quot;,.) %&gt;% gsub(&quot;\\\\D&quot;,&quot;&quot;,.) searchterm &lt;- paste(runoff_nums, collapse = &quot;&quot;) runoff_only_names &lt;- runoff_names %&gt;% gsub(paste0(&quot;[&quot;,searchterm,&quot;]&quot;),&quot;&quot;,.) %&gt;% gsub(separator,&quot;&quot;,.) runoff_new_numbers &lt;- runoff_nums %&gt;% as.numeric() %&gt;% as.character() runoff_new_numbers[is.na(runoff_new_numbers)] &lt;- &quot;&quot; # names(cos_data) &lt;- runoff_new_numbers %&gt;% gsub(&quot;\\\\d+&quot;,separator,.) %&gt;% paste0(runoff_only_names,.,runoff_new_numbers) return(cos_data) } 1.4.5 Mark the needed periods This function can be used to create a viscos_options(&quot;name_COSperiod&quot;). The period column is a vector of increasing integer that is set to 0 for rows that are out of the period. The current solution for defining this columns is not realy satisfying, but the problem seems to be non-trival… Life is short and it was the best that the authors could come out with so far. In its current iteration the function takes cos_data and the two integers start_month and end_month as inputs, that can be used to define the to-be marked periods. The function can be directly used on raw data since the remove_junk and complete_dates are internaly applied to. This does however also mean that it needs to be used with care! The computation is done in the following way: (I) Before starting the acutal marking the variable period_range and the out_of_period vector is defined. (II) With the help of the vectors the periods can be marked in two steps: First, all the starting months within cos_data are marked and the cumulative sum is used to count the periods within the data.frame. At the beginning of the first period, the counter is at “1” and becomes “2” with the beginning of the second period and so on. Secondly, the out_of_period of all years is set back to zero again by checking which months of the data are equal to the out_of_period entries. There are at least two apparent problems with that solution: One problem is that the last year is not extracted properly if start_month &gt; end_month. To compensate this problem the dplyr shenanigans are added at the end of the fucntion. The other problem is that that the first and last period are also included in the solution even if they are not complete! #&#39; calculate periods #&#39; #&#39; Mark the periods within cos_data. # The marking uses a monthly resolution, which are defined by the integers #&#39; `start_month` and `end_month`. #&#39; #&#39; @param cos_data The data.frame, which contains the runoff information #&#39; @return The runoff data.frame reduced and ordered according to the #&#39; hydrological years within the data. #&#39; \\strong{Note:} The periods columns are formatted as characters! #&#39; #&#39; @import dplyr #&#39; @import magrittr #&#39; #&#39; @export mark_periods &lt;- function(cos_data, start_month = 10, end_month = 9) { assert_dataframe(cos_data) cos_data %&lt;&gt;% remove_junk %&gt;% complete_dates() # (I) get labels for the months if (start_month &lt;= end_month ) { period_range &lt;- seq(start_month,end_month) out_of_period &lt;- seq(1,12) %&gt;% extract( !(seq(1,12) %in% period_range) ) } else if (start_month &gt; end_month) { range_1 &lt;- seq(start_month,12) range_2 &lt;- seq(1,end_month) period_range &lt;- c(range_1,range_2) out_of_period &lt;- seq(1,12) %&gt;% extract( !(seq(1,12) %in% period_range) ) } # (II) mark periods: eval_diff &lt;- function(a) {c(a[1],diff(a))} cos_data[[viscos_options(&quot;name_COSperiod&quot;)]] &lt;- cos_data[[viscos_options(&quot;name_COSmonth&quot;)]] %in% c(start_month) %&gt;% eval_diff %&gt;% pmax(.,0) %&gt;% cumsum cos_data$period[cos_data[[viscos_options(&quot;name_COSmonth&quot;)]] %in% out_of_period] &lt;- 0 # corrections for last year max_year &lt;- max(cos_data[[viscos_options(&quot;name_COSyear&quot;)]]) cos_data %&lt;&gt;% dplyr::mutate( period = ifelse( ( (.[[viscos_options(&quot;name_COSyear&quot;)]] == max_year) &amp; (.[[viscos_options(&quot;name_COSmonth&quot;)]] &gt; end_month) ), 0, period ) ) return(cos_data) } Here are two additonal examples that display the slected periods and the numbering: require(magrittr) require(visCOS) # mark_periods example 1: Hydrological years (September till August) # note that the last year is not complete, so the counter jumps back to 0 ex1 &lt;- get_cos_data_example() %&gt;% mark_periods(.,start_month = 9, end_month = 8) plot(ex1$period, xlab=&quot;Timestep&quot;, ylab = &quot;# of hydrological year&quot;) # mark_periods example 2: Summer Months (June till August) ex2 &lt;- get_cos_data_example() %&gt;% mark_periods(.,start_month = 6, end_month = 8) plot(ex2$period, xlab=&quot;Timestep&quot;, ylab = &quot;# year of summer months&quot;) 1.4.6 Transform the cos_data into xts This function is actually just a small wrapper around the xts::xts function for the purposes of visCOS. A notable quirk of the function is that the names of the header are put to lower cases via the tolower function and possible leading zeros in the enumeration of the basins are removed. Currently it is not exported as users can use xts themselves perfectly well, and it is felt that the function does not provide enough added value for the user. #&#39; Convert cos_data to xts-format #&#39; #&#39; Converts the cos_data (class: data_frame) into an xts object #&#39; #&#39; @param cos_data data_frame of the cos_data (see: xxx) #&#39; @return xts object of the cos_data data.frame #&#39; #&#39; @import zoo #&#39; @importFrom xts xts #&#39; @import magrittr cos_data_as_xts &lt;- function(cos_data) { # pre assert_dataframe(cos_data) assert_junk(cos_data) assert_complete_date(cos_data) # everything is set to lower case cos_data &lt;- remove_leading_zeros(cos_data) %&gt;% magrittr::set_names(names(cos_data) %&gt;% tolower) name_posix &lt;- viscos_options(&quot;name_COSposix&quot;) %&gt;% tolower cos_data_as_xts &lt;- xts(x = cos_data[], # ,names(cos_data) != name_posix order.by = cos_data[[name_posix]]) # return(cos_data_as_xts) } "],
["options.html", "2 Options", " 2 Options visCOS provides a set of global options for controlling the package. They are implemented with the help of the GlobalOptions package. This section defines the code for the global options and explains the individual options: #&#39; visCOS global options #&#39; #&#39; Get and set the global options of visCOS #&#39; #&#39; These are the options you can adapt by executing the function #&#39; (default values) #&#39; \\preformatted{ #&#39; viscos_options( #&#39; # data.frame column names #&#39; name_o = &quot;qobs&quot;, # name of the first time-series data (observations) #&#39; name_s = &quot;qsim&quot;, # name of the second time-series data (simulations) #&#39; name_COSyear = &quot;yyyy&quot;, # name of year-column #&#39; name_COSmonth = &quot;mm&quot;, # name of month-column #&#39; name_COSday = &quot;dd&quot;, # name of day-column #&#39; name_COShour = &quot;hh&quot;, # name of hour-column #&#39; name_COSmin = &quot;min&quot;, # name of minute-column #&#39; name_COSposix = &quot;posixdate&quot;, # name of the complete-date-column #&#39; name_COSperiod = &quot;period&quot;, # name of the marked-period column #&#39; missing_data = -999, # marker for missing data in the o_columns #&#39; # plot options #&#39; color_o = &quot;steelblue&quot;, # color associated with the first o time-series data #&#39; color_s= &quot;orange&quot;, # color associated with the second s time-series data #&#39; of_limits = c(0,1) # limits of the plotted objective functions #&#39; ) #&#39; } #&#39; #&#39; @examples #&#39; viscos_options(&quot;name_o&quot;) #&#39; viscos_options(name_o = &quot;OtherData&quot;) #&#39; viscos_options(&quot;name_o&quot;) #&#39; @export viscos_options &lt;- GlobalOptions::setGlobalOptions( # data.frame column names name_o = &quot;qobs&quot;, name_s = &quot;qsim&quot;, data_unit = &quot;(m^3/s)&quot;, name_COSyear = &quot;yyyy&quot;, name_COSmonth = &quot;mm&quot;, name_COSday = &quot;dd&quot;, name_COShour = &quot;hh&quot;, name_COSmin = &quot;min&quot;, name_COSposix = &quot;posixdate&quot;, name_COSperiod = &quot;period&quot;, missing_data = -999, # plot options color_o = &quot;steelblue&quot;, color_s = &quot;orange&quot;, of_limits = c(0,1) ) "],
["ojective-functions.html", "3 Ojective Functions 3.1 Code 3.2 References", " 3 Ojective Functions This chapter defines the objective functions that are used in visCOS. Objective functions, in short \\(of\\), are an important part of the hydrological model calibration. Their importance arises from the approximate nature of the models and the large uncertainties of the process. Hydrological models are not only imperfect, in the sense that they simplify nature, but in most cases structurally different than the reality so that different models or their respective parametrisations approximate the hydrograph equally well. Thus, over the time a many objective functions have been developed to either make the model-results better interpretable/comparable or to address specific problems of given objective functions. 3.1 Code This section defines the code for different objective functions. If possible the calculation is done with the help of the hydroGOF package, if not an R-code solution is tried. Currently 4 main objective functions are provided in visCOS. They can be directly extracted from the cos_data data.frame via the main_of_ functions. Other objective functions are provided to, but no special extraction and visualisation functions are provided for them. For the explanation and definition of the objective function it is assumed that \\(o\\) are the observations (defined by name_o in visCOS) and \\(s\\) are the simulation(defined by name_s in visCOS). #&#39; Objective Functions #&#39; #&#39; Different objective Functions, provided by visCOS. A detailed description #&#39; of each of the provided objective function is provided in the respective #&#39; vignette #&#39; #&#39; @param o The reference data or observations (o_data) #&#39; @param s The created data or the simulations (s_data) #&#39; @name of_overview NULL 3.1.1 The “Main” Objective Functions Currently the main objective functions are the Nash-Sutcliffe Efficiency, the Kling-Gupta Efficiency, the percentage bias and the correlation. 3.1.1.1 Nash-Sutcliffe Efficiency The Nash-Sutcliffe Criterion \\(NSE\\) is by far the most used efficiency criterion in hydrology. In the hydrological context \\(o\\) usually represents a set of runoff-observation and \\(s\\) a set of simulations. The \\(NSE\\) is defined in the same way as the general definition of the coefficient of determination \\(R^2\\): \\[ NSE = \\frac{\\sum_{t=1}^T \\big( o(t)-s(t) \\big)^2} {\\sum_{t=1}^T \\big( o(t)-\\bar{o} \\big)^2} . \\] The variable \\(\\bar{o}\\) represents the average of \\(o\\). The \\(NSE\\) can be seen as the relational the estimator \\(s\\) and the estimator resulting form the average of the data. It can can have values between minus infinity and 1 with 1 being the perfect fit, 0 when the mean of \\(s\\) is as good as the mean of \\(o\\) and negative values are even worse. The code for the \\(NSE\\) computation is: #&#39; Nash-Sutcliffe Efficiency #&#39; #&#39; @rdname of_overview #&#39; @import hydroGOF #&#39; @export of_nse &lt;- function(o,s) { as.numeric( NSE(s,o) ) } 3.1.1.2 Kling-Gupta Efficiency The Kling-Gupta Efficiency \\(KGE\\) was introduced by Gupta et al. (2009) to alleviate some of the shortcomings of the \\(NSE\\). In their paper they argue why the \\(NSE\\) tends to overate simulations with small variance (note: in the context of the paper \\(\\textrm{simulations} = s\\)) and propose their efficiency criterion instead. The \\(KGE\\) is defined as: \\[ KGE = 1 - ED, \\] with \\[ ED = \\sqrt{\\big(corr(o,s)-1 \\big)^2 + \\big(\\alpha(o,s)-1 \\big)^2 + \\big(\\beta(o,s)-1 \\big)^2 }. \\] In which \\(\\alpha(o,s) = \\frac{\\sigma_s}{ \\sigma_o }\\) is the standard deviation \\(\\sigma\\) of \\(s\\) divided by the \\(\\sigma\\) of \\(o\\), \\(\\beta(o,s) = \\mu_s / \\mu_o\\) with\\(\\mu\\) being the arithmetic mean and \\(corr(o,s)\\) as the Pearson’s correlation coefficient (see below). The value range and the quality is similar to the \\(NSE\\). The code for the \\(KGE\\) computation is: #&#39; Kling-Gupta Efficiency #&#39; #&#39; @rdname of_overview #&#39; @import hydroGOF #&#39; @export of_kge &lt;- function(o,s) { as.numeric( KGE(s,o) ) } 3.1.1.3 Percentage Bias The percentage of bias \\(p_{bias}\\) is defined as the sum of the differences between \\(o\\) and \\(s\\) divided by the sum of \\(o\\): \\[ p_{bias} = 100*\\frac{\\sum_{t=1}^T [ o(t)-s(t) ] }{\\sum_{t=1}^T o(t)}. \\] The \\(100*\\) is just a scaling factor applied to express \\(p_{bias}\\) as a percentage. The code for the \\(p_{bias}\\) computation is: #&#39; Percentage Bias #&#39; #&#39; @rdname of_overview #&#39; @import hydroGOF #&#39; @export of_p_bias &lt;- function(o,s) { as.numeric( pbias(s,o) ) } 3.1.1.4 Pearson’s correlation coefficient Pearson’s correlation coefficient, \\(r\\) or \\(corr(o,s)\\), is a measure of the linear relationship between \\(o\\) and \\(s\\). It is defined as: \\[ r \\equiv corr(o,s) = \\frac{cov(o,s)}{\\sigma_s*\\sigma_o}, \\] where \\(cov(...)\\) denotes the covariance. The correlation coefficient can take on values between -1 and 1. The former corresponds to an inverse and the latter to a direct relationship and the closer the values is to zero the weaker is the implied correlation. The code for the correlation is: #&#39; Correlation #&#39; #&#39; @rdname of_overview #&#39; @import hydroGOF #&#39; @export of_cor &lt;- function(o,s) { diag( cor(o,s) ) } 3.1.2 Ohter Objective Functions Descriptions shall follow 3.1.2.1 Root Mean Sqaured Error \\[ \\frac{\\sum_{t=1}^T \\big( o(t)-s(t) \\big)^2} {T} \\] #&#39; Root Mean Sqaured Error #&#39; #&#39; @rdname of_overview #&#39; @import hydroGOF #&#39; @export of_rmse &lt;- function(o,s) { as.numeric( rmse(s,o) ) } 3.1.2.2 Inverted Nash-Sutcliffe Efficiency \\[ nse^{-1} = \\frac{\\sum_{t=1}^T \\big( s(t)-o(t) \\big)^2} {\\sum_{t=1}^T \\big( s(t)-\\bar{s} \\big)^2} \\] #&#39; Inverted Nash-Sutcliffe Efficiency #&#39; #&#39; @rdname of_overview #&#39; @import hydroGOF #&#39; @export of_invert_nse &lt;- function(o,s) { as.numeric( NSE(o,s) ) } 3.1.2.3 Ratio of the Standard Deviations \\[ rsd = \\frac{\\sigma_s}{ \\sigma_o } \\] #&#39; Ratio of Standard Deviations #&#39; #&#39; @rdname of_overview #&#39; @import hydroGOF #&#39; @export of_rsd &lt;- function(o,s) { as.numeric( rSD(s,o) ) } 3.1.2.4 Ratio of the Means \\[ rmeans = \\mu_s / \\mu_o\\] #&#39; Ratio of Means #&#39; #&#39; @rdname of_overview #&#39; @export of_rmeans &lt;- function(o,s) { as.numeric( mean(s)/mean(o) ) } 3.1.2.5 Volumetric Efficiency The volumetric efficiency, \\(VE\\), uses the absolute distance between observation and simulation instead of the quadratic and is bound between 0 to 1. \\[ VE = 1- \\frac{\\sum_{t=1}^T abs\\big( s(t)-o(t) \\big)} {\\sum_{t=1}^T o(t) } \\] #&#39; Volumetric Efficiency #&#39; #&#39; @rdname of_overview #&#39; @import hydroGOF #&#39; @export of_ve &lt;- function(o,s) { as.numeric( VE(s,o) ) } 3.2 References Percentage Bias: Yapo P. O., Gupta H. V., Sorooshian S., 1996. Automatic calibration of conceptual rainfall-runoff models: sensitivity to calibration data. Journal of Hydrology. v181 i1-4. 23-48 Nash-Sutcliffe Efficiency: Nash, J. E. and J. V. Sutcliffe (1970), River flow forecasting through conceptual models part I -A discussion of principles, Journal of Hydrology, 10 (3), 282-290 Kling-Gupta Efficiency: Gupta, Hoshin V., Harald Kling, Koray K. Yilmaz, Guillermo F. Martinez. Decomposition of the mean squared error and NSE performance criteria: Implications for improving hydrological modelling. Journal of Hydrology, Volume 377, Issues 1-2, 20 October 2009, Pages 80-91. DOI: 10.1016/j.jhydrol.2009.08.003. ISSN 0022-1694 Volumetric Efficiency: Criss, R. E. and Winston, W. E. (2008), Do Nash values have value? Discussion and alternate proposals. Hydrological Processes, 22: 2723-2725. doi: 10.1002/hyp.7072 "],
["time-aggregates.html", "4 Time Aggregates 4.1 Examples 4.2 Code", " 4 Time Aggregates In hydrology it is often useful to summarise the data respect to a given time dimension. In visCOS this can be done by using the aggregate_time function. The function takes COSERO data.frame and aggregates them according to a chosen time dimension. Note, that the name of the dimension can be specified via the options. 4.1 Examples require(ggplot2, quietly = TRUE) require(visCOS, quietly = TRUE) Daily runoff aggregation: cos_data &lt;- visCOS::get_cos_data_example() runoff_aggregate_dd &lt;- aggregate_time(cos_data, &quot;dd&quot;) # plot data: ggplot(runoff_aggregate_dd) + geom_line(aes(x = idx, y = value, col = obs_sim)) + scale_colour_manual(values = c(viscos_options(&quot;color_o&quot;), viscos_options(&quot;color_s&quot;))) + facet_wrap( ~ basin,ncol = 1) + theme_minimal() Monthly runoff aggregation: runoff_aggregate_mm &lt;- aggregate_time(cos_data, &quot;mm&quot;) # plot data: ggplot(runoff_aggregate_mm) + geom_line(aes(x = idx, y = value, col = obs_sim)) + scale_colour_manual(values = c(viscos_options(&quot;color_o&quot;), viscos_options(&quot;color_s&quot;))) + scale_x_discrete(limits = runoff_aggregate_mm$time_aggregate) + facet_wrap( ~ basin, scales = &quot;free&quot;) + theme_minimal() Yearly runoff aggregation: runoff_aggregate_yyyy &lt;- aggregate_time(cos_data, &quot;yyyy&quot;) # plot data: ggplot(runoff_aggregate_yyyy) + geom_point(aes(x = idx, y = value, col = obs_sim)) + scale_colour_manual(values = c(viscos_options(&quot;color_o&quot;), viscos_options(&quot;color_s&quot;))) + facet_wrap( ~ basin) + scale_x_discrete(limits = runoff_aggregate_yyyy$time_aggregate, labels = abbreviate) + theme_minimal() Yearly and monthly runoff aggregation: runoff_aggregate_yyyymm &lt;- aggregate_time(cos_data, &quot;yyyy-mm&quot;) # plot data: ggplot(runoff_aggregate_yyyymm) + geom_line(aes(x = idx, y = value, col = obs_sim)) + scale_colour_manual(values = c(viscos_options(&quot;color_o&quot;), viscos_options(&quot;color_s&quot;))) + scale_x_discrete(limits = runoff_aggregate_yyyymm$time_aggregate, labels = abbreviate) + facet_wrap( ~ basin,ncol = 1) + theme_minimal() + theme(axis.text.x = element_text(angle = 90, hjust = 1)) 4.2 Code This section defines the code for the aggregate_time function. The time aggregation is done by cutting the needed information out of the date-string. This is a rough, but works nicely and seems to be more commonly used than you would expect. #&#39; Time Aggregation #&#39; #&#39; Aggregates the COSERO data.frame (\\code{cos_data}) according to the #&#39; timely resolution defined via \\code{aggregation}. Possible #&#39; resolution-choices are \\code{&#39;yyyy&#39;} - year, \\code{&#39;mm&#39;} - month and #&#39; \\code{&#39;dd}&#39; - day and combinations thereof. #&#39; #&#39; @param cos_data the COSERO data.frame as used within visCOS #&#39; @param aggregation string that defines the resolution of the aggregation. #&#39; @import magrittr #&#39; @import ggplot2 #&#39; @import pasta #&#39; @export aggregate_time &lt;- function(cos_data, aggregation = &quot;mm&quot;) { # cutting_bounds &lt;- c(Inf,-Inf) if (grepl(&quot;dd&quot;,aggregation)) { cutting_bounds[1] &lt;- min(9,cutting_bounds[1]) cutting_bounds[2] &lt;- max(11,cutting_bounds[2]) } if (grepl(&quot;mm&quot;,aggregation)) { cutting_bounds[1] &lt;- min(6,cutting_bounds[1]) cutting_bounds[2] &lt;- max(7,cutting_bounds[2]) } if (grepl(&quot;yyyy&quot;,aggregation)) { cutting_bounds[1] &lt;- min(1,cutting_bounds[1]) cutting_bounds[2] &lt;- max(4,cutting_bounds[2]) } ###### function and string definitions regex_for_cos_selection &lt;- viscos_options(&quot;name_o&quot;) %|% viscos_options(&quot;name_s&quot;) # aggregation function: aggregator_fun &lt;- function(k,data_frame){ the_aggregation &lt;- aggregate(data_frame[[k]] ~ data_frame$date_selection, FUN = mean) return(the_aggregation[ ,2]) } ##### # If cos_data is not provided fully, the date is completed automatically # + junk is removed from the data frame full_cos_data &lt;- cos_data %&gt;% visCOS::complete_dates() %&gt;% visCOS::remove_junk() # aggregate: cos_with_aggreggation &lt;- cbind.data.frame( full_cos_data, date_selection = substr(full_cos_data$posixdate, cutting_bounds[1], cutting_bounds[2]) %&gt;% as.factor() ) names_cos_selection &lt;- grep( regex_for_cos_selection, names(cos_with_aggreggation) %&gt;% tolower, value = TRUE ) selected_cos_rows &lt;- grep(regex_for_cos_selection, names(cos_with_aggreggation), ignore.case = TRUE) time_aggregate &lt;- selected_cos_rows %&gt;% sapply(.,function(x) aggregator_fun(x,cos_with_aggreggation)) %&gt;% data.frame(idx = 1:nrow(.), time_aggregate = unique(cos_with_aggreggation$date_selection), .) %&gt;% set_names(., c(&quot;idx&quot;,&quot;time_aggregate&quot;,names_cos_selection)) # melt the data in a tidy format: melted_time_aggregate &lt;- time_aggregate %&gt;% reshape2::melt(., id.vars = c(&quot;idx&quot;,&quot;time_aggregate&quot;)) %&gt;% cbind.data.frame(., basin = .$variable %&gt;% gsub(regex_for_cos_selection,&quot;&quot;,.) %&gt;% gsub(&quot;\\\\D&quot;,&quot;&quot;,.) %&gt;% as.integer, obs_sim = .$variable %&gt;% gsub(viscos_options(&quot;name_o&quot;) %&amp;% &quot;.*&quot;,viscos_options(&quot;name_o&quot;),.) %&gt;% gsub(viscos_options(&quot;name_s&quot;) %&amp;% &quot;.*&quot;,viscos_options(&quot;name_s&quot;),.)) return(melted_time_aggregate) } "],
["summaries-of-important-objective-functions.html", "5 Summaries of important objective functions 5.1 Code", " 5 Summaries of important objective functions This chapter explains the code to calculate the main objective functions \\(of\\) used in visCOS. As explained in respective section objective functions are a pivotal part of model calibration. As of now, visCOS focuses on 4 main objective function: NSE, KGE, Pearson’s Correlation and the Percentage bias (the respective definitions are given here). The main objective functions for the overall data and the marked periods can be computed through the function main_of_compute. In order to run the function the period have to be marked first, e.g. through the mark_periods function. Additionally, visCOS already provides two different options to create plots for the main objective functions: main_of_rasterplot and main_of_barplot. Both functions create a list with 4 ggplot figures. Each entry in the list corresponds to one of the main objective functions and both lists can be saved to html embedded .jpgs with the serve function. Examples: Computing the main objective functions require(visCOS) require(magrittr) of_values &lt;- get_cos_data_example() %&gt;% mark_periods() %&gt;% main_of_compute() of_values ## of basin.1 basin.2 ## 1 NSE 0.5177309 0.8012919 ## 2 KGE 0.7246877 0.7489862 ## 3 p_bias 0.3000000 -12.5000000 ## 4 CORR 0.8177663 0.9107391 ## 5 NSE_period.1 0.1326604 0.7566200 ## 6 NSE_period.2 0.7096110 0.8168895 ## 7 KGE_period.1 0.4138710 0.8487406 ## 8 KGE_period.2 0.8419666 0.6820128 ## 9 p_bias_period.1 8.8000000 -8.6000000 ## 10 p_bias_period.2 -6.9000000 -15.9000000 ## 11 CORR_period.1 0.8243198 0.8806770 ## 12 CORR_period.2 0.8577983 0.9385221 Plotting the results of main objective function with bar plots: of_values &lt;- get_cos_data_example() %&gt;% mark_periods() %&gt;% main_of_barplot() %&gt;% extract2(1) %&gt;% plot() Plotting the results of main objective function with a raster: of_values &lt;- get_cos_data_example() %&gt;% mark_periods() %&gt;% main_of_rasterplot() %&gt;% extract2(2) %&gt;% plot() 5.1 Code This section defines the code for the main_of-function-family. # --------------------------------------------------------------------------- # Code for the Main Objective Functions (main_of) # authors: Daniel Klotz, Johannes Wesemann, Mathew Herrnegger # !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! 5.1.1 Compute the Main Objective Functions The purpose of this function is to extract a the main of objective functions from the COSERO data.frame. The objective functions are extracted for each basin separately and computed for the entire length of the data, as well as for each period separately. The computational part of the function works as follows. In step (I) the non-marked periods of cos_data (columns of viscos_options(&quot;name_COSperiod&quot;) which are smaller then 0) are excluded from further calculations. The thereby obtained data.frame is named evaluation_data. # --------------------------------------------------------------------------- #&#39; Get basic objective function for cos_data #&#39; #&#39; Calculate basic objective functions(NSE, KGE, percentage BIAS, Correlation) #&#39; for every basin and the chosen periods. #&#39; #&#39; @param cos_data cos_data data.frame. #&#39; @return list of basic objective function evaluated for the different #&#39; hydrological years and over the whole timespan. #&#39; #&#39; @import hydroGOF #&#39; @import dplyr #&#39; #&#39; @export main_of_compute &lt;- function(cos_data) { # def: ==================================================================== assert_dataframe(cos_data) name_o &lt;- viscos_options(&quot;name_o&quot;) name_s &lt;- viscos_options(&quot;name_s&quot;) name_period &lt;- viscos_options(&quot;name_COSperiod&quot;) if (!exists(name_period, where = cos_data)) { stop(&quot;Error! Period-Column missing in cos_data, use `mark_periods`&quot;) } evaluation_data &lt;- cos_data[cos_data[[name_period]] &gt; 0, ] number_of_basins &lt;- evaluation_data %&gt;% names() %&gt;% unique() %&gt;% grepl(name_o, ., ignore.case = TRUE) %&gt;% sum() data_periods &lt;- evaluation_data %&gt;% magrittr::extract2(name_period) %&gt;% unique() number_of_periods &lt;- data_periods %&gt;% length # compute main-of for entire data: ======================================== o_pick &lt;- dplyr::select(evaluation_data,starts_with(name_o)) %&gt;% unname() s_pick &lt;- dplyr::select(evaluation_data,starts_with(name_s)) %&gt;% unname() nse_all &lt;- hydroGOF::NSE(s_pick,o_pick) kge_all &lt;- hydroGOF::KGE(s_pick,o_pick) p_bias_all &lt;- hydroGOF::pbias(s_pick,o_pick) corr_all &lt;- cor(s_pick,o_pick) %&gt;% diag() # compute periodwise main-of: ============================================= # pre allocations: ######################################################## NSE_period &lt;- matrix(nrow = number_of_periods, ncol = as.integer(number_of_basins), data = NA) KGE_period &lt;- NSE_period p_bias_period &lt;- NSE_period CORR_period &lt;- NSE_period # calculation loop, proabbly slow :( ###################################### for (k in 1:number_of_periods) { o_pick &lt;- dplyr::filter(evaluation_data,period == data_periods[k]) %&gt;% dplyr::select(starts_with(name_o)) %&gt;% unname() s_pick &lt;- dplyr::filter(evaluation_data,period == data_periods[k]) %&gt;% dplyr::select(starts_with(name_s)) %&gt;% unname() NSE_period[k,1:number_of_basins] &lt;- hydroGOF::NSE(s_pick,o_pick) KGE_period[k,1:number_of_basins] &lt;- hydroGOF::KGE(s_pick,o_pick) p_bias_period[k,1:number_of_basins] &lt;- hydroGOF::pbias(s_pick,o_pick) CORR_period[k,1:number_of_basins] &lt;- cor(s_pick,o_pick) %&gt;% diag(.) } # clean up: =============================================================== obj_names &lt;- c(&quot;NSE&quot;,&quot;KGE&quot;,&quot;p_bias&quot;,&quot;CORR&quot;, paste(&quot;NSE_period&quot;,1:number_of_periods,sep = &quot;.&quot;), paste(&quot;KGE_period&quot;,1:number_of_periods,sep = &quot;.&quot;), paste(&quot;p_bias_period&quot;,1:number_of_periods,sep = &quot;.&quot;), paste(&quot;CORR_period&quot;,1:number_of_periods,sep = &quot;.&quot;) ) obj_fun &lt;- data.frame(of = obj_names, basin = rbind(nse_all, kge_all, p_bias_all, corr_all, NSE_period, KGE_period, p_bias_period, CORR_period), row.names = NULL) return(obj_fun) } 5.1.2 Plotting # --------------------------------------------------------------------------- #&#39; Plot main objective function values #&#39; #&#39; Currently two options for plotting the main objectives are provided by #&#39; visCOS: Plotting the different objective functions values as a set of #&#39; bar plots \\code{barplot_of} and plotting a summary table in form of #&#39; a large raster of all the objective function values \\code{rasterplot_of}. #&#39; #&#39; @name plot_main_of NULL 5.1.2.1 Bar Plot # --------------------------------------------------------------------------- #&#39; Bar plot for the Main Objective Function Values #&#39; #&#39; @rdname of_overview #&#39; @export main_of_barplot &lt;- function(cos_data) { # def: ==================================================================== assert_dataframe(cos_data) # functions: ============================================================== assign_ofgroups &lt;- function(of_melted,mof_names) { of_string &lt;- as.character(of_melted$of) of_melted$of_group &lt;- of_string %&gt;% replace(.,startsWith(of_string,mof_names[1]),mof_names[1]) %&gt;% replace(.,startsWith(of_string,mof_names[2]),mof_names[2]) %&gt;% replace(.,startsWith(of_string,mof_names[3]),mof_names[3]) %&gt;% replace(.,startsWith(of_string,mof_names[4]),mof_names[4]) return(of_melted) } # plot-list function: barplot_fun &lt;- function(of_name,of_melted) { of_to_plot &lt;- of_melted %&gt;% filter( of_group == of_name) if (of_name == &quot;p_bias&quot;) { gglimits &lt;- c(-viscos_options(&quot;of_limits&quot;)[2]*100, viscos_options(&quot;of_limits&quot;)[2]*100) } else { gglimits &lt;- viscos_options(&quot;of_limits&quot;) } plt_out &lt;- ggplot(data = of_to_plot) + geom_bar(stat = &quot;identity&quot;, position = &quot;identity&quot;, aes(x = of, y = value, fill = value)) + facet_wrap(~ variable, ncol = 1) + ggtitle(of_name) + ylim(gglimits) return(plt_out) } # computations: =========================================================== mof_names &lt;- c(&quot;NSE&quot;,&quot;KGE&quot;,&quot;CORR&quot;,&quot;p_bias&quot;) of &lt;- main_of_compute(cos_data) num_basins &lt;- ncol(of) - 1 of_melted &lt;- suppressMessages( reshape2::melt(of) ) %&gt;% assign_ofgroups(.,mof_names) # plotting ================================================================ plot_list &lt;- lapply(mof_names, function(x) barplot_fun(x,of_melted)) %&gt;% magrittr::set_names(mof_names) return(plot_list) } 5.1.2.2 Raster-Plot #&#39; Bar plot for the Main Objective Function Values #&#39; #&#39; @rdname of_overview #&#39; @import pasta #&#39; @export main_of_rasterplot &lt;- function(cos_data) { mof_names &lt;- c(&quot;NSE&quot;,&quot;KGE&quot;,&quot;CORR&quot;,&quot;p_bias&quot;) regex_main_of &lt;- mof_names %.% &quot;*&quot; assert_dataframe(cos_data) of &lt;- main_of_compute(cos_data) # plot_list &lt;- lapply(regex_main_of,function(x) plot_fun_raster(x,of)) %&gt;% set_names(mof_names) return(plot_list) } # plot function ------------------------------------------------------------- plot_fun_raster &lt;- function(regex_single_of,of) { # function definitions ==================================================== extract_single_of &lt;- function(of){ idx &lt;- grep(regex_single_of,of$of) return(of[idx, ]) } add_facet_info &lt;- function(of) { facet_column &lt;- nrow(of) %&gt;% magrittr::subtract(1) %&gt;% rep(&quot;period&quot;,.) %&gt;% c(&quot;overall&quot;,.) return( cbind(of,facets = facet_column) ) } reverse_basin_levels &lt;- function(prepared_data) { prepared_data$variable &lt;- factor(prepared_data$variable, levels = prepared_data$variable %&gt;% levels() %&gt;% rev() ) return(prepared_data) } reverse_facetting_levels &lt;- function(prepared_data) { prepared_data$facets &lt;- factor(prepared_data$facets, levels = prepared_data$facets %&gt;% levels() %&gt;% rev() ) return(prepared_data) } bind_and_round_value &lt;- function(of,gglimits,digits) { dplyr::mutate(of, value = pmax(value,gglimits[1]) %&gt;% pmin(.,gglimits[2]) %&gt;% round(.,digits) ) } # computation ============================================================= if (regex_single_of == &quot;p_bias.*&quot;) { # pbias has different limits :( gglimits &lt;- c(-viscos_options(&quot;of_limits&quot;)[2]*100, viscos_options(&quot;of_limits&quot;)[2]*100) } else { gglimits &lt;- viscos_options(&quot;of_limits&quot;) } # prepared_data &lt;- of %&gt;% extract_single_of() %&gt;% add_facet_info() %&gt;% reshape2::melt(., id.vars = c(&quot;of&quot;,&quot;facets&quot;)) %&gt;% reverse_basin_levels() %&gt;% reverse_facetting_levels() %&gt;% bind_and_round_value(.,gglimits,2) # ggplot ================================================================== plt_out &lt;- ggplot(prepared_data, aes(of,variable, fill = value), environmnet = environment()) + geom_raster(position = &quot;identity&quot;) + coord_fixed(ratio = 5) + facet_grid(~ facets, scales = &quot;free_x&quot;, space = &quot;free&quot;) + theme( legend.position = &quot;none&quot;) + geom_tile(color = &quot;white&quot;, size = 0.25 ) + geom_text(aes(of,variable, label = as.character(value,2)), color = &quot;black&quot;) return(plt_out) } "],
["flow-duration-curves.html", "6 Flow Duration Curves 6.1 Example 6.2 Code 6.3 References", " 6 Flow Duration Curves Flow-duration curves represent the relationship between the magnitue and the frequency of a streamflow. They provide an estimate of the percentage of time a given streamflow was exceeded within the evaluated time frame. Foster [1934] attributes the first use of flow duration curves to Clemens Herschel around 1880. Since they have been used for a wide array of applications. visCOS provides a function to compute the data for flow-duration curves and a function to plot them directly. The former function is called fdc_compute. It computes the flow exceedance properties and returns a data.frame. The calculations are adapted from the method used within the hydroTSM package. It is currently rather slow. The plot-function is called fdc_plot. Internally it uses fdc_compute for the data preparation and generates a facetted ggplot object from it. In the plot each basin is a facet and each sub-plot shows the \\(o\\)-data and \\(s\\)-data (see: Introduction). 6.1 Example Flow duration curves can be plotted in visCOS in the following way: library(visCOS) cos_data &lt;- get_cos_data_example() fdc_plot(cos_data) 6.2 Code 6.2.1 Computing the data for the flow duration curves #&#39; Compute Flow Duration Curves #&#39; #&#39; Computes the flow duration curves (fdc) for the `cos_data` data.frame. #&#39; The calculations are adapted from the method used within the hydroTSM package. #&#39; @param cos_data A data.frame with columns as used throughout visCOS #&#39; @import magrittr #&#39; @import dplyr #&#39; @importFrom purrr map_df #&#39; @import pasta #&#39; @export fdc_compute &lt;- function(cos_data) { # defensive code: assert_dataframe(cos_data) # def: order_bound_data &lt;- function(bound_data) { ordred_fdc_data &lt;- bound_data %&gt;% mutate(obs_sim = key %&gt;% gsub( viscos_options(&quot;name_o&quot;) %&amp;% &quot;.*&quot;, viscos_options(&quot;name_o&quot;), ., ignore.case = TRUE ) %&gt;% gsub( viscos_options(&quot;name_s&quot;) %&amp;% &quot;.*&quot;, viscos_options(&quot;name_s&quot;), ., ignore.case = TRUE ), basin_idx = key %&gt;% gsub(viscos_options(&quot;name_o&quot;),&quot;&quot;,.,ignore.case = TRUE) %&gt;% gsub(viscos_options(&quot;name_s&quot;),&quot;&quot;,.,ignore.case = TRUE) %&gt;% gsub(&quot;\\\\D&quot;,&quot;&quot;,.) %&gt;% as.numeric) return(ordred_fdc_data) } # computation: cos_data_only &lt;- cos_data %&gt;% select(starts_with(viscos_options(&quot;name_o&quot;)), starts_with(viscos_options(&quot;name_s&quot;))) exceedance_values &lt;- map_df(cos_data_only,calc_percent_exceedance) %&gt;% tidyr::gather() %&gt;% magrittr::extract(&quot;value&quot;) fdc_data &lt;- cos_data_only %&gt;% tidyr::gather() %&gt;% cbind.data.frame(exceedance = exceedance_values) %&gt;% magrittr::set_names(c(&quot;key&quot;,&quot;value&quot;,&quot;exceedance&quot;)) %&gt;% order_bound_data(.) return(fdc_data) } # function to calculated the percent exceedance (x-axis) for the fdc calc_percent_exceedance &lt;- function(q) { q_sorted &lt;- sort(q) q_zero_index &lt;- which(q_sorted == 0) nzeros &lt;- length(q_zero_index) ind &lt;- match(q, q_sorted) n &lt;- length(q) percent_exeedence &lt;- rep(NA, n) percent_exeedence[1:n] &lt;- sapply(1:n, function(j, y) {percent_exeedence[j] &lt;- length(which(y &gt;= y[j]))}, y = q) percent_exeedence &lt;- percent_exeedence/n return(percent_exeedence) } 6.2.2 Plotting the Flow duration curves #&#39; Plot Flow Duration Curves #&#39; #&#39; Plots the flow duration curves (fdc) for `cos_data`. #&#39; The function uses `ggplot` to so and facets the different basins into #&#39; separate subplots. Each subplot shows the fdc of the \\eqn{o}-data and #&#39; the \\eqn{s}-data. #&#39; @export #&#39; @import ggplot2 fdc_plot &lt;- function(cos_data, log_y = TRUE, log_x = FALSE, ...) { # def: # maybe we have to account certain limits for the logs, e.g: # if (log_y | log_x &amp; min(ylim) == 0) { # ylim &lt;- range(q, na.rm = TRUE) # tmp &lt;- unlist(q) # tmp[which(tmp == 0)] &lt;- NA # ylim[1] &lt;- min(tmp, na.rm = TRUE) # } logfun &lt;- function(data,take_log){ if(take_log){ return(log(data)) } else ( return(data) ) } # computation: fdc_data &lt;- fdc_compute(cos_data) gplot &lt;- ggplot(fdc_data) + geom_line(aes(x = logfun(exceedance,log_x), y = logfun(value,log_y), color = obs_sim)) + facet_wrap(~ basin_idx) return(gplot) } 6.3 References Foster, H.A. (1934): Duration curves. ASCE Trans., 99, 1213-1267 Vogel, R. M.; Fennessy, N. M. (1994): Flow-Duration Curves. I: New Interpretation and Confidence Intervals. JWRMD 120, No. 4 "],
["plotting-runoff-peaks-plots.html", "7 Plotting Runoff Peaks Plots 7.1 Examples: 7.2 Code 7.3 References", " 7 Plotting Runoff Peaks Plots The function peak_plot lets users explore the highest events in among the available basins. It provides a list of ggplot2 plots, containing an overview plot (overview), a scatter plot (scatter) and detail plots of the individual events (event_plot). Instead of explaining the properties of each plot in detail it is best to get an intuition of the function by looking at some examples. 7.1 Examples: For the examples 10 events are extracted from a runoff example require(visCOS) cos_data &lt;- get_cos_data_example() peakplots &lt;- peak_plot(cos_data, n_events = 10L) The peakplots list does now contain plots for each basin within the cos_data data.frame: names(peakplots) ## [1] &quot;basin0001&quot; &quot;basin0002&quot; For each basin the a set of plots (overview,scatter,event_plot) are saved within a list for each basin. In the following the plots for basin 1 are shown: names(peakplots$basin0001) ## [1] &quot;overview&quot; &quot;scatter&quot; &quot;event_plot1&quot; &quot;event_plot2&quot; &quot;event_plot3&quot; ## [6] &quot;event_plot4&quot; &quot;event_plot5&quot; &quot;event_plot6&quot; &quot;event_plot7&quot; &quot;event_plot8&quot; ## [11] &quot;event_plot9&quot; &quot;event_plot10&quot; The overview plot shows the entire time series of data1 and data2 of the basin. The found events are marked with black dots. The overview plot for basin 1 is: peakplots$basin0001$overview The scatter plot shows the found events within a scatter plot, where data1 is the x-axis and data2 on the y-axis. In the following an example for basin 1 is given. peakplots$basin0001$scatter Detail plots for each of the found events are given in form of the event_plot objects. Here an example: peakplots$basin0001$event_plot5 7.2 Code This part of the document defines the code of peak_plot #&#39; Plot List for Runoff Peaks #&#39; @export #&#39; #&#39; @import ggplot2 #&#39; @import dplyr #&#39; @import magrittr #&#39; @importFrom tibble tibble peak_plot &lt;- function(cos_data,n_events= 10L, window_size = 24L) { # pre: assert_dataframe(cos_data) n_events_int &lt;- as.integer(n_events) window_size_int &lt;- as.integer(window_size) if( is.na(n_events_int) | is.nan(n_events_int) | is.infinite(n_events_int) | !is.integer(n_events_int) ) { stop(&quot;n_events is ill defined&quot;) } if( is.na(window_size) | is.nan(window_size) | is.infinite(window_size) | !is.integer(window_size) ) { stop(&quot;window_size is ill defined&quot;) } data1 &lt;- cos_data %&gt;% select( starts_with(viscos_options(&quot;name_o&quot;)) ) data2 &lt;- cos_data %&gt;% select( starts_with(viscos_options(&quot;name_s&quot;)) ) data_numbers &lt;- names(data1) %&gt;% gsub(viscos_options(&quot;name_o&quot;),&quot;&quot;,.,ignore.case = TRUE) %&gt;% gsub(&quot;\\\\D&quot;,&quot;&quot;,.,ignore.case = TRUE) # make plotlist: plotlist &lt;- lapply(1:ncol(data1), function(x) plotlist_one_basin(data1[,x], data2[,x], n_events_int, window_size_int)) %&gt;% set_names(.,paste(&quot;basin&quot;, data_numbers, sep =&quot;&quot;)) return(plotlist) } 7.2.1 Generating the Plots for one basin. This is the function for generating the different plots for one basin. At first the provided time series are grouped into a tibble, then the peaks of the observations are obtained via the peak_finder function and organised. Then ggplot2 is used for plotting. plotlist_one_basin &lt;- function(qobs,qsim,n_events_int,window_size_int) { single_data &lt;- tibble::tibble(time = as.integer(1:length(qobs)), obs = as.double(qobs), sim = as.double(qsim)) # peak_idx &lt;- find_peaks(single_data$obs,m = window_size_int) peak_organised &lt;- tibble::tibble(idx = as.integer(peak_idx), peak_obs = single_data$obs[peak_idx], peak_sim = single_data$sim[peak_idx]) highest_peaks_organised &lt;- peak_organised$peak_obs %&gt;% sort(decreasing = TRUE) %&gt;% .[1:n_events_int] %&gt;% &#39;%in%&#39;(peak_organised$peak_obs,.) %&gt;% which( . ) %&gt;% peak_organised[., ] # overview_plot &lt;- ggplot() + geom_line(data = single_data,aes(x = time, y = sim), col = viscos_options(&quot;color_s&quot;)) + geom_line(data = single_data,aes(x = time, y = obs), col = viscos_options(&quot;color_o&quot;)) + geom_point(data = highest_peaks_organised, aes(idx, peak_obs)) overview_scatter &lt;- ggplot() + geom_point(data = single_data, aes(obs,sim), color = &quot;#DDDDDD&quot;) + geom_abline() + geom_point(data = highest_peaks_organised, aes(peak_obs,peak_sim), size = 4) + expand_limits(x = 0, y = 0) sub_plots &lt;- lapply(1:nrow(highest_peaks_organised), function(x) sub_peakplot_fun(x,window_size_int,highest_peaks_organised,single_data) ) %&gt;% set_names(.,paste(&quot;event_plot&quot;,1:length(.),sep=&quot;&quot;)) return(overview = append(list(overview = overview_plot,scatter = overview_scatter), sub_plots)) } 7.2.2 Function to find peaks The function for finding the peaks was proposed and developed by the cross validated user “stas g” in this thread. This is by far not the only option/possibility to approach the peak finding task. Other nice ideas for finding peaks can be found in this cross validated thread. #### # peak finder function: find_peaks &lt;- function (x, m = 3){ shape &lt;- diff(sign(diff(x, na.pad = FALSE))) pks &lt;- sapply(which(shape &lt; 0), FUN = function(i){ z &lt;- i - m + 1 z &lt;- ifelse(z &gt; 0, z, 1) w &lt;- i + m + 1 w &lt;- ifelse(w &lt; length(x), w, length(x)) if(all(x[c(z : i, (i + 2) : w)] &lt;= x[i + 1])) return(i + 1) else return(numeric(0)) }) pks &lt;- unlist(pks) pks } 7.2.3 Subplot Function This function is a wrapper around ggplot, which is used to generate the individual event plots. #### # sub plot function: sub_peakplot_fun &lt;- function(x, window_size, highest_peaks_organised, peak_data) { point &lt;- highest_peaks_organised[x,] plot_sub &lt;- ggplot() + geom_line(data = peak_data[(point$idx - window_size):(point$idx + window_size),], aes(x = time, y = sim), col = &quot;orange&quot;) + geom_line(data = peak_data[(point$idx - window_size):(point$idx + window_size),], aes(x = time, y = obs), col = &quot;steelblue&quot;) + geom_point(data = point, aes(idx, peak_obs)) return(plot_sub) } 7.3 References http://stats.stackexchange.com/questions/22974/how-to-find-local-peaks-valleys-in-a-series-of-data (checked 12/2016) http://stats.stackexchange.com/questions/36309/how-do-i-find-peaks-in-a-dataset (checked 12/2016) "],
["exploring-objective-functions.html", "8 Exploring Objective Functions 8.1 Example 8.2 Code", " 8 Exploring Objective Functions This section defines the code of a shiny gadget. It enables the interactive exploration of (hydro-) graphs for the different basins. The gadget shows always the corresponding objective function for the selected graph. Furthermore, one can get the selected data by clicking on “done” at the end of a session. The following examples provide a good overview of what the function can do. 8.1 Example This chapter gives examples of explore_cos_data. For the pre-requirements take a look at the introduction. Running the explore_cos_data function without any options opens a shiny gadget in the viewer: Information on the objective functions can be found here. viscos_options(color_o = &quot;green&quot;, color_s = &quot;red&quot;) explore_cos_data(runoff_example) Users can select different basins via the selection box (# basins:) on the top-left and interactively zoom and move the graph in the center by clicking on it or moving the date switches below the graph. While doing so the objective functions (presented in the table below) are re-calculated for the chosen time window. 8.2 Code In the following paragraphs the code of the shiny app is defined. The computations of the app are defined in the server part and the appearance in the ui. 8.2.1 Explore the data This function represents the main part of the shiny app. The current solution forces users to enumerate their basins with and the shiny app needs some pre-calculation, which need to be calculated before the app is started. These calculations are made before the app as such is defined. They include: Defensive code Transform data into xts (d_xts). Save numeration of basins within the variable d_nums. #&#39; explore cos_data with Objective Functions #&#39; #&#39; Runs a Shiny App which can be used to get an overview of a cos_data time #&#39; series object. #&#39; #&#39; @param d_xts cos_data formatted as time series #&#39; #&#39; @import shiny #&#39; @import miniUI #&#39; @importFrom xts xts #&#39; @import dplyr #&#39; @import magrittr #&#39; @import dygraphs #&#39; @import hydroGOF #&#39; @import pasta #&#39; @importFrom purrr map_df #&#39; #&#39; @export #&#39; #&#39; @examples #&#39; # get example data, #&#39; # explore the model performance #&#39; cos_data &lt;- get_cos_data_example() #&#39; explore_cos_data(cos_data) explore_cos_data &lt;- function(cos_data, of_list = list( nse = of_nse, kge = of_kge, p_bias = of_p_bias, r = of_cor ), start_date = NULL, end_date = NULL) { # pre-sets # (I) Defense if (is.null(names(of_list))){ names(of_list) &lt;- paste(&quot;of&quot;, 1:length(of_list), sep = &quot;_&quot;) } clean_cos_data &lt;- cos_data %&gt;% remove_leading_zeros if ( !viscos_options(&quot;name_COSposix&quot;) %in% names(clean_cos_data) ) { clean_cos_data %&lt;&gt;% complete_dates } # (II) d_xts &lt;- cos_data_as_xts(clean_cos_data) # (III) idx_names &lt;- names(d_xts) %&gt;% tolower %&gt;% grepl(viscos_options(&quot;name_o&quot;),.) d_nums &lt;- d_xts %&gt;% names() %&gt;% .[idx_names] %&gt;% gsub(&quot;\\\\D&quot;,&quot;&quot;,.) %&gt;% as.integer %&gt;% unique The server-side of the shiny app is rather lengthy but not too difficult. The major readability problems occur because of the unusual formatting enforced by shinyApps. server &lt;- function(input, output, session) { # (I) get strings used in the naming of clean_cos_data: unique_data_names &lt;- names(clean_cos_data) %&gt;% gsub(&quot;\\\\d&quot;,&quot;&quot;,.) %&gt;% tolower %&gt;% unique x_string &lt;- unique_data_names[ unique_data_names %&gt;% grep(viscos_options(&quot;name_o&quot;),.) ] y_string &lt;- unique_data_names[ unique_data_names %&gt;% grep(viscos_options(&quot;name_s&quot;),.) ] # (II) select data: selector_x &lt;- reactive({ x_string %&amp;% input$basin_num %&amp;% &quot;$&quot; }) # &quot;$&quot; terminates the searchstring; see regex selector_y &lt;- reactive({ y_string %&amp;% input$basin_num %&amp;% &quot;$&quot; }) selected_data &lt;- reactive({ select(clean_cos_data, matches( selector_x() ), matches( selector_y() ) ) %&gt;% select(x = matches( selector_x() ), y = matches( selector_y() )) }) # (III) create xts-formated table for use in dygraphs: xts_selected_data &lt;- reactive ({ xts(selected_data(), order.by = clean_cos_data[[viscos_options(&quot;name_COSposix&quot;)]]) }) # (IV) create plots: output$hydrographs &lt;- renderDygraph({ dygraph( xts_selected_data() ) %&gt;% dyAxis(&quot;y&quot;, label = visCOS::viscos_options(&quot;data_unit&quot;)) %&gt;% dySeries(&quot;x&quot;, label = visCOS::viscos_options(&quot;name_o&quot;), color = viscos_options(&quot;color_o&quot;)) %&gt;% dySeries(&quot;y&quot;, label = visCOS::viscos_options(&quot;name_s&quot;), color = viscos_options(&quot;color_s&quot;)) %&gt;% dyRangeSelector(height = 20, strokeColor = &quot;&quot;) %&gt;% dyCrosshair(direction = &quot;vertical&quot;) %&gt;% dyOptions(includeZero = TRUE, retainDateWindow = TRUE) }) # (IV) get dygraph date bounds (switches): selcted_from &lt;- reactive({ if (!is.null(start_date)) { start_date } else if (!is.null(input$hydrographs_date_window)) { input$hydrographs_date_window[[1]] } }) selcted_to &lt;- reactive({ if (!is.null(end_date)) { end_date } else if (!is.null(input$hydrographs_date_window)) { input$hydrographs_date_window[[2]] } }) # (V) extract time_window for the stats header: output$selected_timewindow &lt;- renderText({ if (!is.null(input$hydrographs_date_window)) paste(strftime(selcted_from(), format = &quot;%d %b %Y&quot;), &quot;-&quot;, strftime(selcted_to(), format = &quot;%d %b %Y&quot;), sep = &quot; &quot;) }) # (VI) calculate stats: sub_slctd &lt;- reactive({ if (!is.null(input$hydrographs_date_window)) xts_selected_data()[paste(strftime(selcted_from(), format = &quot;%Y-%m-%d-%H-%M&quot;), strftime(selcted_to(), format = &quot;%Y-%m-%d-%H-%M&quot;), sep = &quot;/&quot;)] }) out_of &lt;- reactive({ if (!is.null(input$hydrographs_date_window)) { map_df(of_list, function(of_,x,y) of_(x,y), x = sub_slctd()$x, y = sub_slctd()$y ) #serve_of( sub_slctd()$x,sub_slctd()$y ) } }) output$slctd_OF &lt;- renderTable(out_of()) # (VII) exit when user clicks on done # When the Done button is clicked, return a value observeEvent(input$done, { returnValue &lt;- list( selected_time = c(strftime(selcted_from(), format = &quot;%Y-%m-%d-%H-%M&quot;),strftime(selcted_to(), format = &quot;%Y-%m-%d-%H-%M&quot;)), selected_data = data.frame(date = index(sub_slctd()), coredata(sub_slctd())), selected_of = out_of() ) stopApp(returnValue) }) } The miniUI is quite spartan. There is an miniButtonBlock that allows to select different basin, as as the dygraph output (i.e hydrographs) for the interactive exploration of the \\(o\\) and \\(s\\) data. The formatted table (slctd_OF) displays the different objective functions, that can be given to explore_cos_data . ui &lt;- miniPage( miniButtonBlock(selectInput(&quot;basin_num&quot;, &quot;# basin:&quot;, choices = d_nums, selected = 1, selectize = FALSE)), miniContentPanel( fillCol( flex = c(4,1), dygraphOutput(&quot;hydrographs&quot;, width = &quot;100%&quot;, height = &quot;100%&quot;), fillCol( align = &quot;center&quot;, textOutput(&quot;selected_timewindow&quot;), tableOutput(&quot;slctd_OF&quot;) ) ) ), gadgetTitleBar(&quot;test&quot;) ) dyCrosshair &lt;- function(dygraph, direction = c(&quot;both&quot;, &quot;horizontal&quot;, &quot;vertical&quot;)) { dyPlugin( dygraph = dygraph, name = &quot;Crosshair&quot;, path = system.file(&quot;examples/plugins/crosshair.js&quot;, package = &quot;dygraphs&quot;), options = list(direction = match.arg(direction)) ) } runGadget(ui,server) } "],
["generate-previews.html", "9 Generate Previews 9.1 Code", " 9 Generate Previews Possibility to save lists of plots into .jpgs and create a linked html file. 9.1 Code #&#39; Serve is still beta #&#39; #&#39; More description shall follow #&#39; @export serve &lt;- function(plotlist, path = &quot;&quot;, fig_width = 800L, fig_height = 500L) { hmtl_filename &lt;- &quot;summary&quot; # establish html-file in chosen folder &#39;%&amp;%&#39; &lt;- function(a,b) paste(a,b,sep = &quot;&quot;) # helper for easier string concatenation fileConn &lt;- file(path %&amp;% hmtl_filename %&amp;% &quot;.html&quot; , &quot;w&quot;) # write html header #writeLines(text = &#39;&lt;!DOCTYPE html&gt;&#39;,fileConn) writeLines(text = &quot;&lt;HEAD&gt;&quot;,fileConn) writeLines(text = &quot; &lt;STYLE type=&#39;text/css&#39;&gt;&quot;,fileConn) writeLines(text = &quot; H1 { text-align: center}&quot;,fileConn) writeLines(text = &quot; &lt;/STYLE&gt;&quot;,fileConn) writeLines(text = &quot;&lt;/HEAD&gt;&quot;,fileConn) #writeLines(text = &#39;&lt;html&gt;&#39;,fileConn) writeLines(text = &#39;&lt;body&gt;&#39;,fileConn) # check which kind of plotlsit we are dealing with: if ( all(names(plotlist) == c(&quot;NSE&quot;,&quot;KGE&quot;,&quot;p_bias&quot;,&quot;CORR&quot;)) ) { list_to_plot &lt;- plotlist } else if ( all(grepl(&quot;basin&quot;,names(plotlist1))) ) { list_to_plot &lt;- unlist(plotlist,recursive = FALSE) } else { stop(&quot;plotlist not known!&quot;) } num_plots &lt;- length(list_to_plot) figure_names &lt;- names(list_to_plot) ## save everything localy &amp; link it within the html file jpg_filenames &lt;- &quot;figure&quot; for (i in 1:num_plots) { writeLines(text = &quot;&lt;H1&gt;&quot; %&amp;% figure_names[i] %&amp;% &quot;&lt;/H1&gt;&quot;,fileConn) plt_name &lt;- jpg_filenames %&amp;% i %&amp;% &quot;.jpg&quot; plt_pathANDname &lt;- path %&amp;% plt_name plt_hmtlInfos &lt;- &quot;&lt;img src=\\&quot;&quot; %&amp;% plt_name %&amp;% &#39;&quot; alt=&quot;plotting_failed&quot; style=&quot;width:800px;height:500px;&quot;&gt;&#39; # writeLines(text = &quot;&lt;H1&gt;&quot; %&amp;% plt_hmtlInfos %&amp;% &quot;&lt;/H1&gt;&quot;, fileConn) jpeg(file = plt_pathANDname, width = fig_width, height = fig_height, units = &quot;px&quot;) plot(list_to_plot[[i]]) dev.off() } close(fileConn) } "],
["defensive-code.html", "10 Defensive Code 10.1 Code 10.2 References", " 10 Defensive Code This section defines the internaly used defensive programming part of visCOS. This are all functions dedicated to ensure that visCOS is working nicely even if it is used wrongly for whatever reason. This often means that a given function has to return an error if certain criteria are not met! Useful examples for such methods can be found in Hadley Wickhams R package assertthat 10.1 Code The subsequent functions are defined in this section function exported assert_junk no assert_complete_date no assert_dataframe no assert_of no 10.1.1 Check if cos_data is “clean” Tests if the given data.frame (cos_data) contains only the columns defined within get_regex_for_cos_data (see: helpers and viscos_options). An exception throws an error. Note that the check is not case sensitive! #&#39; @import magrittr assert_junk &lt;- function(cos_data) { regEx &lt;- get_regex_for_cos_data() assertChunk &lt;- names(cos_data) %&gt;% grepl(regEx, ., ignore.case = TRUE) if (any(assertChunk == FALSE)) { stop(&quot;there is still unwanted columns in the data. Try: remove_junk&quot;) } } 10.1.2 Check date completeness A rough check for the needed date- and/or time-columns within the provided cos_data. The function is rahter basic. It only checks if the names of the viscos_options(&quot;name_COSyear&quot;) column and viscos_options(&quot;name_COSposix&quot;) column exist (see: viscos_options). An exceptions throws an error. assert_complete_date &lt;- function(cos_data) { OK_COSdate &lt;- any(names(cos_data) == viscos_options(&quot;name_COSyear&quot;)) OK_POSIXdates &lt;- any(names(cos_data) == viscos_options(&quot;name_COSposix&quot;)) # choose error messag depending on which columns are missing! if (!OK_COSdate &amp; !OK_POSIXdates) { stop(&quot;No COSdates and no POSIXct-dates in the data!&quot;) } else if (OK_COSdate &amp; !OK_POSIXdates) { stop(&quot;NO POSIXct fomrated column within the cos_data!&quot;) } else if (!OK_COSdate &amp; OK_POSIXdates) { stop(&quot;NO COSdate year within the cos_data!&quot;) } } 10.1.3 Check if the data is a data.frame Tests if data is a data.frame and returns an error if not. # uses stop if the input: &quot;data&quot; is not of class &quot;data.frame&quot; assert_dataframe &lt;- function(data) { require(&quot;tibble&quot;, quietly = TRUE) if ( !is.data.frame(data)&amp;!is.tibble(data) ) stop(&quot;data needs to be a data_frame!&quot;) } 10.2 References Wickham, H. (2013). assertthat: Easy pre and post assertions. https://CRAN.R-project.org/package=assertthat "],
["helpers.html", "11 Helpers 11.1 Code", " 11 Helpers This section collects small and helpful functions/scripts that are used throughout visCOS. None of the functions is exported! 11.1 Code The subsequent functions are defined below function exported get_regex_for_cos_data no get_basin_numbers no set_panel_size no 11.1.1 Get a Regular Expression String for the needed columns This function can be called to get the names of the 8 allowed column-names within visCOS. get_regex_for_cos_data takes no input, as it gets the information directly from the global options (see: viscos_options section). get_regex_for_cos_data &lt;- function() { regex_pattern &lt;- paste(&quot;^&quot;,viscos_options(&quot;name_COSyear&quot;),&quot;$|&quot;, &quot;^&quot;,viscos_options(&quot;name_COSmonth&quot;),&quot;$|&quot;, &quot;^&quot;,viscos_options(&quot;name_COSday&quot;),&quot;$|&quot;, &quot;^&quot;,viscos_options(&quot;name_COShour&quot;),&quot;$|&quot;, &quot;^&quot;,viscos_options(&quot;name_COSmin&quot;),&quot;$|&quot;, viscos_options(&quot;name_o&quot;),&quot;.*|&quot;, viscos_options(&quot;name_s&quot;),&quot;.*|&quot;, viscos_options(&quot;name_COSposix&quot;),&quot;|&quot;, viscos_options(&quot;name_COSperiod&quot;), sep = &quot;&quot;) return(regex_pattern) } 11.1.2 Extract the numeration of the basins This function fetches the number of basins from the provided data.frame (cos_data) by removing all the non-digits characters from the column names. get_basin_numbers &lt;- function(cos_data) { require(&quot;magrittr&quot;, quietly = TRUE) assert_dataframe(cos_data) assert_junk(cos_data) # d_names &lt;- names(cos_data) d_nums &lt;- d_names %&gt;% gsub(&#39;\\\\D&#39;,&#39;&#39;,.) %&gt;% unique d_nums &lt;- d_nums[!(d_nums == &quot;&quot;)] %&gt;% as.integer return(d_nums) } "]
]
