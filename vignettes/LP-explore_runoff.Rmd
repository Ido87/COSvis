---
title: "Code for Exploring Objective Functions"
author: "Daniel Klotz"
date: "13 Juli 2016"
output:
  html_document:
    number_sections: yes
---

```{r setup, include=FALSE, purl=FALSE}
  knitr::opts_chunk$set(eval = FALSE, tidy = FALSE)
```

# Introduction
This section defines the code of a [shiny app](http://shiny.rstudio.com/)
that lets users explore the (hydro-) graphs for the different basins in
conjunction with objective functions for the user-selected time-window. The
calculation of the objective functions are independent of the code defined in
the section about `main_of_compute`, since simpler constructions are preferable
in the case at hand and more information is given to the user.

The computations of the app are defined in the `server` part and the
appearance in the `ui`. 

# Example
In this chapter it is shown, how the function `explore_runoff` can be 
used to take a closer look at the data series you loaded. Only prerequirements 
are properly loaded data and correctly addressed `viscos_options`. Additionally, 
you can adapt the *color_data* options in the `viscos_options`. Information on 
the *objective functions* can be found [here](ex-OF_explanation.html)

Running the `explore_runoff` with your data as input, a shiny app is 
started in a new window (in this case an example .jpg with explanations):
```{r,purl=FALSE, eval = FALSE}
viscos_options(color_data1 = "green", color_data2 = "red")
explore_runoff(runoff_example)
```

![](figures/eg_explore_basin.JPG)

Users can select different basins via the selection box (*# basins:*) on the
top-left and interactively zoom and move the graph in the center by clicking
on it or moving the date switches below the graph. While doing so the
objective functions (presented in the table below) are re-calculated for the
chosen time window. 


# Code
In the following paragraphs the code of the shiny app is defined.

## `explore_runoff`
This function represents the main part of the shiny app. 

```{r}
  #' explore runoff_data with Objective Functions
  #'
  #' Runs a Shiny App which can be used to get an overview of a runoff_data time
  #' series object.
  #'
  #' @param d_xts runoff_data formatted as time series
  #' 
  #' @import shiny 
  #' @import miniUI
  #' @importFrom xts xts
  #' @import dplyr
  #' @import magrittr
  #' @import dygraphs 
  #' @import hydroGOF
  #' @importFrom purrr map_df
  #' 
  #' @export
  #' 
  #' @examples
  #' # get example data,
  #' # explore the model performance
  #' d_runoff <- get_runoff_example()
  #' explore_runoff(d_runoff)
explore_runoff <- function(runoff_data,
                                   of_list = list(
                                     nse = of_nse, 
                                     kge = of_kge, 
                                     pBIAS = of_pbias,
                                     r = of_cor
                                   ),
                                   start_date = NULL,
                                   end_date = NULL) {
  
```

At its current state the shiny app needs some pre-calculation, which are defined 
in this part of the code: 

- (I) Defensive code 
- (II) Transform data into `xts` (`d_xts`). 
- (III) Save numeration of basins within the variable `d_nums`.

**Note** that this approach forces users to enumerate their basins with
integers. `Doubles` would be transformed into integers by the `as.integer`
command!
```{r}
  # pre-sets
  # (I) Defense
  if (is.null(names(of_list))){
    names(of_list) <- paste("of", 1:length(of_list), sep = "_")
  }
  clean_runoff_data <- runoff_data %>% remove_leading_zeros
  if ( !viscos_options("name_COSposix") %in% names(clean_runoff_data) ) {
    clean_runoff_data %<>% prepare_complete_date
  }
  # (II)
  d_xts <- runoff_as_xts(clean_runoff_data)
  # (III)
  idx_names <- names(d_xts) %>%
    tolower %>% 
    grepl(viscos_options("name_o"),.)
  d_nums <- d_xts %>%
      names() %>%
      .[idx_names] %>%
      gsub("\\D","",.) %>%
      as.integer %>%
      unique
```

The server-side of the shiny app is rather lengthy but not too difficult.
The major readability problems occur because of the unusual formatting enforced
by shiny. The `reactive({})` marks all the interactive parts of the server.
The calculations are saved in the output-structures, which is handed over to the
`ui`. The graphs are saved/plotted to `output$hydrographs` and the objective
functions to `output$slctd_OF`. The start and end of the current time window is
handed  as string to the variable `output$selected_timewindow`. This requires
some transformation from the obtained `xts` values. This is done with
`strftime(., format = "%d %b %Y)`, which converts between character
representations and objects of `POSIXlt` and `POSIXct`.
```{r}
  server <- function(input, output, session) {
    # (I) get strings used in the naming of clean_runoff_data:
    unique_data_names <- names(clean_runoff_data) %>%
      gsub("\\d","",.) %>%
      tolower %>%
      unique
    x_string <- unique_data_names[ unique_data_names %>%
                                     grep(viscos_options("name_o"),.) ]
    y_string <- unique_data_names[ unique_data_names  %>%
                                     grep(viscos_options("name_s"),.) ]
    # (II) select data:
    '%&%' <- function(a,b) paste(a,b,sep = "") # %&% as substitute for function
    selector_x <- reactive({ x_string %&% input$basin_num %&% "$" }) # "$" terminates the searchstring; see regex
    selector_y <- reactive({ y_string %&% input$basin_num %&% "$" })
    selected_data <- reactive({
      select(clean_runoff_data,
             matches( selector_x() ),
             matches( selector_y() )
             ) %>%
        select(x = matches( selector_x() ),
               y = matches( selector_y() ))
    })
    # (III) create xts-formated table for use in dygraphs:
    xts_selected_data <- reactive ({
      xts(selected_data(),
          order.by = clean_runoff_data[[viscos_options("name_COSposix")]])
    })
    # (IV) create plots:
    output$hydrographs <- renderDygraph({
      dygraph( xts_selected_data() ) %>%
        dySeries("x",
                 label = visCOS::viscos_options("name_o"),
                 color = viscos_options("color_data1")) %>%
        dySeries("y",
                 label = visCOS::viscos_options("name_s"),
                 color = viscos_options("color_data2")) %>%
        dyRangeSelector(height = 20, strokeColor = "") %>% 
        dyCrosshair(direction = "vertical") %>%
        dyOptions(includeZero = TRUE) 
    })
    # (IV) get dygraph date bounds (switches):
    selcted_from <- reactive({
      if (!is.null(start_date)) {
        start_date
      } else if (!is.null(input$hydrographs_date_window)) {
        input$hydrographs_date_window[[1]]
      }
    })
    selcted_to <- reactive({
      if (!is.null(end_date)) {
        end_date
      } else if (!is.null(input$hydrographs_date_window)) {
        input$hydrographs_date_window[[2]]
      }

    })
    # (V) extract time_window for the stats header:
    output$selected_timewindow <- renderText({
      if (!is.null(input$hydrographs_date_window))
        paste(strftime(selcted_from(), format = "%d %b %Y"),
              "-",
              strftime(selcted_to(), format = "%d %b %Y"),
              sep = " ")
    })
    # (VI) calculate stats:
    sub_slctd <- reactive({
      if (!is.null(input$hydrographs_date_window))
        xts_selected_data()[paste(strftime(selcted_from(), format = "%Y-%m-%d-%H-%M"),
                               strftime(selcted_to(), format = "%Y-%m-%d-%H-%M"),
                               sep = "/")]
    })
    out_of <- reactive({
      if (!is.null(input$hydrographs_date_window)) {
          map_df(of_list, function(of_,x,y) of_(x,y), 
                 x = sub_slctd()$x, 
                 y = sub_slctd()$y ) #serve_of( sub_slctd()$x,sub_slctd()$y )
      }
    })
    
    output$slctd_OF <- renderTable(out_of())
    # (VII) exit when user clicks on done 
     # When the Done button is clicked, return a value
    observeEvent(input$done, {
      returnValue <- list(
        selected_time = c(strftime(selcted_from(), format = "%Y-%m-%d-%H-%M"),strftime(selcted_to(), format = "%Y-%m-%d-%H-%M")),
        selected_data = data.frame(date = index(sub_slctd()),
                                   coredata(sub_slctd())),
        selected_of = out_of()
      )
      stopApp(returnValue)
    })
  }
```

The `miniUI` is quite spartan. It consists a input selection (`selectInput`),
which allows user to select different basins, the `dygraph` output `hydrographs`
for the interactive exploration of the $x$ and $y$ data and a formatted table
output (`slctd_OF`), which displays the different objective functions (defined
in `explore_of`). The `hr` command block separates this table from the
`dygraph` output via a small-grey line.
```{r}
  ui <- miniPage(
    miniButtonBlock(selectInput("basin_num",
                                "# basin:",
                                choices = d_nums,
                                selected = 1, 
                                selectize = FALSE)),
    miniContentPanel(
      fillCol(
        flex = c(4,1),
        dygraphOutput("hydrographs", width = "100%", height = "100%"),
        fillCol(
          align = "center",
          textOutput("selected_timewindow"),
          tableOutput("slctd_OF")
        )
      )
    ),
    gadgetTitleBar("test")
  )
```

```{r}
dyCrosshair <- function(dygraph, 
                        direction = c("both", "horizontal", "vertical")) {
  dyPlugin(
    dygraph = dygraph,
    name = "Crosshair",
    path = system.file("examples/plugins/crosshair.js", 
                       package = "dygraphs"),
    options = list(direction = match.arg(direction))
  )
}
```


```{r}
  runGadget(ui,server)
}
```

