---
title: "Code for Exploring Objective Functions"
author:
- "Daniel Klotz, Johannes Wesemann, Mathew Herrnegger"
date: "13 Juli 2016"
output:
  html_document:
    number_sections: yes
---

```{r setup, include=FALSE, purl=FALSE}
  knitr::opts_chunk$set(eval = FALSE, tidy = FALSE)
```

# Introduction

```{r,purl=FALSE, eval = FALSE}
viscos_options(color_o = "green", color_s = "red")
explore_runoff(runoff_example)
```

![](figures/eg_explore_basin.JPG)

```{r}
  #' explore cos_data with Objective Functions
  #'
  #' Runs a Shiny App which can be used to get an overview of a cos_data time
  #' series object.
  #'
  #' @param d_xts cos_data formatted as time series
  #'
  #' @import shiny
  #' @import pasta
  #' @import miniUI
  #' @importFrom xts xts
  #' @import dplyr
  #' @import magrittr
  #' @import dygraphs
  #' @import hydroGOF
  #' @importFrom purrr map_df
  #'
  #' @export
  #'
  #' @examples
  #' # get example data,
  #' # explore the model performance
  #' cos_data <- get_cos_data_example()
  #' explore_runoff(cos_data)
explore_runoff2 <- function(cos_data,
                            start_date = NULL,
                            end_date = NULL) {
  ## pre-sets
  # (I) Defense
  clean_cos_data <- cos_data %>% remove_leading_zeros
  if ( !viscos_options("name_COSposix") %in% names(clean_cos_data) ) {
    clean_cos_data %<>% complete_dates
  }
  # (II)
  d_xts <- cos_data_as_xts(clean_cos_data)
  # (III)
  idx_names <- names(d_xts) %>%
    tolower %>%
    grepl(viscos_options("name_o"),.)
  d_nums <- d_xts %>%
      names() %>%
      .[idx_names] %>%
      gsub("\\D","",.) %>%
      as.integer %>%
      unique
```

The server-side of the shiny app is rather lengthy but not too difficult.
The major readability problems occur because of the unusual formatting enforced
by shinyApps.
```{r}
  server <- function(input, output, session) {
    # (I) get strings used in the naming of clean_cos_data:
    unique_data_names <- names(clean_cos_data) %>%
      gsub("\\d","",.) %>%
      tolower %>%
      unique
    x_string <- unique_data_names[ unique_data_names %>%
                                     grep(viscos_options("name_o"),.) ]
    y_string <- unique_data_names[ unique_data_names  %>%
                                     grep(viscos_options("name_s"),.) ]
    # () select data:
    selector_x <- reactive({x_string %&% input$basin_num %&% "$"}) # "$" terminates the searchstring; see regex
    selector_y <- reactive({y_string %&% input$basin_num %&% "$"})
    pre_selected_data <- reactive({
      select(clean_cos_data,
             matches( selector_x() ),
             matches( selector_y() )) %>%
      select(x = matches( selector_x() ),
             y = matches( selector_y() ))
      # %>% 
      #   dplyr::mutate(integer_idx = 1:nrow(.), 
      #                 posix = clean_cos_data[[viscos_options("name_COSposix")]]) 
    })
    # pre_selected_data_2 <- reactive({
    #    data.frame( pre_selected_data() ) %>% 
    #     mutate(lin_x = ifelse(posix > strftime(selcted_from(), format = "%Y-%m-%d-%H-%M") &
    #                           posix < strftime(selcted_to(), format = "%Y-%m-%d-%H-%M"),
    #                             predict.lm(
    #                               lm(x ~ integer_idx, data = pre_selected_data()),
    #                               newdata = pre_selected_data()),
    #                             0)
    #            )
    #    })
    # debug: 
    output$debug <- renderText(head(strftime(selcted_from(), format = "%Y-%m-%d-%H-%M")))
    # 
    # selected_data <- reactive({ subset(pre_selected_data_2(), select = -c(integer_idx,posix) ) })
    # xts_selected_data <- reactive({
    #   xts(selected_data(),
    #       order.by = clean_cos_data[[viscos_options("name_COSposix")]])
    # })
    # # (V) create plots:
    # output$hydrographs <- renderDygraph({
    #   dygraph( xts_selected_data() ) %>%
    #     dySeries("x",
    #              label = visCOS::viscos_options("name_o"),
    #              color = viscos_options("color_o")) %>%
    #     dySeries("y",
    #              label = visCOS::viscos_options("name_s"),
    #              color = viscos_options("color_s")) %>%
    #     dySeries("lin_x",
    #               label = "lin_x",
    #               color = "magenta") %>% 
    #     dyRangeSelector(height = 20, strokeColor = "") %>%
    #     dyCrosshair(direction = "vertical") %>%
    #     dyOptions(includeZero = TRUE)
    # })

    
    # () get dygraph date bounds (switches):
    selcted_from <- reactive({
      if (!is.null(start_date)) {
        start_date
      } else if (!is.null(input$hydrographs_date_window)) {
        input$hydrographs_date_window[[1]]
      }
    })
    selcted_to <- reactive({
      if (!is.null(end_date)) {
        end_date
      } else if (!is.null(input$hydrographs_date_window)) {
        input$hydrographs_date_window[[2]]
      }

    })
 
    # () exit when user clicks on done
     # When the Done button is clicked, return a value
    observeEvent(input$done, {
      returnValue <- list(
        selected_time = c(strftime(selcted_from(), format = "%Y-%m-%d-%H-%M"),strftime(selcted_to(), format = "%Y-%m-%d-%H-%M")),
        selected_data = data.frame(date = index(sub_slctd()),
                                   coredata(sub_slctd())),
        selected_of = out_of()
      )
      stopApp(returnValue)
    })
  }
```

The `miniUI` is quite spartan. There is an `miniButtonBlock` that allows to select different basin, as as the `dygraph` output (i.e `hydrographs`)
for the interactive exploration of the $o$ and $s$ data. The formatted table (`slctd_OF`) displays the different objective functions, that can be given to `explore_runoff` .
```{r}
  ui <- miniPage(
    miniButtonBlock(selectInput("basin_num",
                                "# basin:",
                                choices = d_nums,
                                selected = 1,
                                selectize = FALSE)),
    miniContentPanel(
        textOutput("debug")
        #dygraphOutput("hydrographs", width = "100%", height = "100%")
      ),
    gadgetTitleBar("test")
  )
```

```{r}
dyCrosshair <- function(dygraph,
                        direction = c("both", "horizontal", "vertical")) {
  dyPlugin(
    dygraph = dygraph,
    name = "Crosshair",
    path = system.file("examples/plugins/crosshair.js",
                       package = "dygraphs"),
    options = list(direction = match.arg(direction))
  )
}
```


```{r}
  runGadget(ui,server)
}
```
